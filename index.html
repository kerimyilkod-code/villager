<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RTS Step 6 – Deer Hunting</title>
  <style>
    :root{ --bg:#0e1020; --panel:#161a33; --panel-2:#1a1f3d; --ink:#e9ecff; }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial; overflow:hidden}
    #topbar{position:fixed; top:8px; left:8px; right:8px; display:flex; align-items:center; gap:10px; z-index:10; padding:8px; border-radius:14px; background:linear-gradient(180deg,var(--panel),#11152a); box-shadow:0 10px 30px rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.06);}
    .res{background:var(--panel-2); padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.04); min-width:84px; text-align:center}
    .res b{display:block; font-size:12px; opacity:.85}
    .res span{font-weight:700}
    #population{background:var(--panel-2); padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.04); min-width:120px; text-align:center}
    #rightpanel{position:fixed; right:8px; top:64px; width:280px; bottom:8px; display:flex; flex-direction:column; gap:10px; z-index:9; pointer-events: none;}
    .card{background:linear-gradient(180deg,var(--panel),#0f1330); padding:12px; border-radius:16px; border:1px solid rgba(255,255,255,.06); pointer-events: auto;}
    .title{font-weight:700; margin-bottom:8px}
    .grid{display:grid; grid-template-columns:repeat(3,1fr); gap:8px}
    .btn{cursor:pointer; padding:8px; border-radius:10px; text-align:center; background:#222853; border:1px solid rgba(255,255,255,.06); color:var(--ink); transition: all 0.2s ease;}
    .btn:hover{background:#2a3068; transform: translateY(-1px);}
    #game{position:absolute; inset:0;}
    #hint{position:fixed; left:8px; bottom:8px; font-size:12px; opacity:.9; background:rgba(0,0,0,.25); padding:6px 8px; border-radius:8px}
    
    .health-bar-container, .wood-bar-container, .stone-bar-container, .deer-health-bar-container, .deer-meat-bar-container {
      margin-top: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; padding: 2px;
    }
    .health-bar, .wood-bar, .stone-bar, .deer-health-bar, .deer-meat-bar {
      height: 12px; border-radius: 2px; transition: width 0.3s ease;
    }
    .health-bar { background: linear-gradient(90deg, #4CAF50, #8BC34A); }
    .wood-bar { background: linear-gradient(90deg, #8B4513, #A0522D); }
    .stone-bar { background: linear-gradient(90deg, #666666, #888888); }
    .deer-health-bar { background: linear-gradient(90deg, #FF6B6B, #FF8E8E); }
    .deer-meat-bar { background: linear-gradient(90deg, #FF9800, #FFC107); }
    .health-text, .wood-text, .stone-text, .deer-health-text, .deer-meat-text {
      font-size: 12px; margin-top: 4px; text-align: center; opacity: 0.8;
    }
    
    .construction-bar-container { margin-top: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; padding: 2px; }
    .construction-bar { height: 8px; background: linear-gradient(90deg, #FF9800, #FFC107); border-radius: 2px; transition: width 0.3s ease; }
    .construction-text { font-size: 11px; margin-top: 2px; text-align: center; opacity: 0.8; }
    
    .resource-icon { width: 16px; height: 16px; vertical-align: middle; margin-right: 4px; }
    .worker-resource { margin-top: 6px; font-size: 11px; text-align: center; opacity: 0.8; display: flex; align-items: center; justify-content: center; gap: 4px; }
    #population img { width: 32px; height: 32px; vertical-align: middle; }

    #loadingScreen {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(135deg, #0e1020, #1a1f3d);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 1000; transition: opacity 0.5s ease;
    }
    #loadingScreen.fade-out { opacity: 0; pointer-events: none; }
    .game-title {
      font-family: 'Segoe Print', 'Bradley Hand', cursive; font-size: 5rem; font-weight: bold;
      background: linear-gradient(45deg, #FFD700, #FFA500, #FF8C00);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; margin-bottom: 2rem;
      animation: glow 2s ease-in-out infinite alternate;
    }
    @keyframes glow {
      from { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
      to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6); }
    }
    .loading-container {
      width: 300px; background: rgba(22, 26, 51, 0.8); border-radius: 15px;
      padding: 2rem; border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }
    .loading-text { text-align: center; font-size: 1.2rem; margin-bottom: 1rem; color: #e9ecff; }
    .progress-bar {
      width: 100%; height: 20px; background: rgba(0, 0, 0, 0.3);
      border-radius: 10px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .progress-fill {
      height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A, #FFD700);
      border-radius: 10px; width: 0%; transition: width 0.3s ease; position: relative; overflow: hidden;
    }
    .progress-fill::after {
      content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: shimmer 2s infinite;
    }
    @keyframes shimmer { 0% { left: -100%; } 100% { left: 100%; } }
    .loading-percentage { text-align: center; font-size: 0.9rem; margin-top: 0.5rem; color: #e9ecff; opacity: 0.8; }
    .game-hint { margin-top: 2rem; text-align: center; font-size: 0.9rem; color: #e9ecff; opacity: 0.7; font-style: italic; }

    .selection-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
    .selection-icon { width: 24px; height: 24px; }
    .btn-icon { width: 20px; height: 20px; margin-bottom: 4px; }

    #menuBtn {
      background: var(--panel-2); padding: 8px 16px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,.04); color: var(--ink); cursor: pointer;
      display: flex; align-items: center; gap: 8px; margin-left: auto; transition: all 0.2s ease;
    }
    #menuBtn:hover { background: #2a3068; transform: translateY(-1px); }

    #menuOverlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.8); display: none; justify-content: center; align-items: center;
      z-index: 1000; backdrop-filter: blur(5px);
    }
    .menu-container {
      background: linear-gradient(180deg, var(--panel), #0f1330); border-radius: 20px;
      padding: 2rem; border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5); width: 300px; max-width: 90vw;
    }
    .menu-title {
      text-align: center; font-size: 1.5rem; margin-bottom: 2rem; font-weight: bold;
      background: linear-gradient(45deg, #FFD700, #FFA500);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .menu-buttons { display: flex; flex-direction: column; gap: 12px; }
    .menu-btn {
      padding: 15px 20px; background: linear-gradient(180deg, #222853, #1a1f3d);
      border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px;
      color: var(--ink); font-size: 1.1rem; cursor: pointer; transition: all 0.3s ease;
      display: flex; align-items: center; gap: 12px; justify-content: flex-start;
    }
    .menu-btn:hover {
      background: linear-gradient(180deg, #2a3068, #222853);
      transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    .menu-btn i { font-size: 1.2rem; width: 24px; text-align: center; }

    #settingsMenu { display: none; }
    .settings-section { margin-bottom: 1.5rem; }
    .settings-title { font-size: 1rem; margin-bottom: 1rem; color: #e9ecff; opacity: 0.9; }
    .volume-control { display: flex; align-items: center; gap: 12px; margin-bottom: 1rem; }
    .volume-slider {
      flex: 1; -webkit-appearance: none; appearance: none; height: 6px;
      background: rgba(255,255,255,0.2); border-radius: 3px; outline: none;
    }
    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
      border-radius: 50%; background: #4CAF50; cursor: pointer;
    }
    .volume-slider::-moz-range-thumb {
      width: 16px; height: 16px; border-radius: 50%;
      background: #4CAF50; cursor: pointer; border: none;
    }
    .back-btn {
      background: rgba(255,255,255,0.1); border: none; color: var(--ink);
      padding: 8px 16px; border-radius: 8px; cursor: pointer;
      margin-top: 1rem; transition: all 0.2s ease;
    }
    .back-btn:hover { background: rgba(255,255,255,0.2); }

    #tooltip {
      position: fixed; display: none; background: var(--panel);
      border: 1px solid rgba(255,255,255,.1); border-radius: 8px;
      padding: 8px; z-index: 1000; pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
    }
    .tooltip-content { font-size: 12px; color: var(--ink); }
    .tooltip-resource { display: flex; align-items: center; gap: 6px; margin: 4px 0; }
    .tooltip-resource img { width: 16px; height: 16px; }
    .tooltip-title {
      font-weight: bold; margin-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,.1); padding-bottom: 4px;
    }
    .tooltip-cost { display: flex; flex-direction: column; gap: 2px; }

    /* 2. Ev Panel Stilleri */
    #secondTownPanel {
      position: fixed; bottom: 8px; right: 8px; z-index: 8;
      transition: transform 0.3s ease;
    }
    #secondTownPanel.collapsed {
      transform: translateY(calc(100% - 40px));
    }
    #secondTownToggle {
      background: linear-gradient(180deg, #8B0000, #A52A2A); padding: 8px 16px;
      border-radius: 10px 10px 0 0; border: 1px solid rgba(255,255,255,.1);
      color: var(--ink); cursor: pointer; text-align: center; font-weight: bold;
      border-bottom: none;
    }
    #secondTownContent {
      background: linear-gradient(180deg, var(--panel), #0f1330); padding: 12px;
      border-radius: 16px 0 16px 16px; border: 1px solid rgba(255,255,255,.06);
      min-width: 200px;
    }
    .second-town-resource {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 8px; padding: 4px 0;
    }
    .second-town-resource:last-child { margin-bottom: 0; }
    .second-town-resource img { width: 20px; height: 20px; margin-right: 8px; }
    .second-town-resource div { display: flex; align-items: center; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Segoe+Print&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

  <audio id="themeMusic1" loop><source src="assets/sounds/main_theme1.mp3" type="audio/mpeg"></audio>
  <audio id="themeMusic2" loop><source src="assets/sounds/main_theme2.mp3" type="audio/mpeg"></audio>
  <audio id="buildSound" preload="auto"><source src="assets/sounds/build.mp3" type="audio/mpeg"></audio>
  <audio id="houseSound" preload="auto"><source src="assets/sounds/house.mp3" type="audio/mpeg"></audio>
  <audio id="stonemasonSound" preload="auto"><source src="assets/sounds/stonemason.mp3" type="audio/mpeg"></audio>
  <audio id="lumberSound" preload="auto"><source src="assets/sounds/lumber.mp3" type="audio/mpeg"></audio>
  <audio id="hunterSound" preload="auto"><source src="assets/sounds/hunter.mp3" type="audio/mpeg"></audio>
</head>
<body>
  <div id="loadingScreen">
    <div class="game-title">Villager</div>
    <div class="loading-container">
      <div class="loading-text">Oyun Yükleniyor...</div>
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div class="loading-percentage" id="loadingPercentage">%0</div>
    </div>
    <div class="game-hint">Kaynakları topla, binalar inşa et, köyünü büyüt!</div>
  </div>

  <div id="menuOverlay">
    <div class="menu-container" id="mainMenu">
      <div class="menu-title">OYUN MENÜSÜ</div>
      <div class="menu-buttons">
        <button class="menu-btn" id="resumeBtn"><i class="fas fa-play"></i>Devam Et</button>
        <button class="menu-btn" id="newGameBtn"><i class="fas fa-plus-circle"></i>Yeni Oyun</button>
        <button class="menu-btn" id="saveBtn"><i class="fas fa-save"></i>Oyunu Kaydet</button>
        <button class="menu-btn" id="loadBtn"><i class="fas fa-folder-open"></i>Oyunu Yükle</button>
        <button class="menu-btn" id="settingsBtn"><i class="fas fa-cog"></i>Ayarlar</button>
      </div>
    </div>

    <div class="menu-container" id="settingsMenu">
      <div class="menu-title">AYARLAR</div>
      <div class="settings-section">
        <div class="settings-title">Ses Ayarları</div>
        <div class="volume-control">
          <i class="fas fa-volume-up"></i>
          <input type="range" class="volume-slider" id="menuVolumeSlider" min="0" max="100" value="50">
          <span id="menuVolumePercent" style="min-width: 40px;">50%</span>
        </div>
        <button class="menu-btn" id="muteToggleBtn">
          <i class="fas fa-volume-mute"></i>Sesi Aç/Kapat
        </button>
      </div>
      <button class="back-btn" id="backToMainBtn"><i class="fas fa-arrow-left"></i> Ana Menüye Dön</button>
    </div>
  </div>

  <!-- 2. Ev Paneli -->
  <div id="secondTownPanel" class="collapsed">
    <div id="secondTownToggle">
      <i class="fas fa-chevron-up"></i> 2. Ev Kaynakları
    </div>
    <div id="secondTownContent">
      <div class="second-town-resource">
        <div><img src="assets/icons/et_icon.png" class="resource-icon" alt="Yiyecek">Yiyecek</div>
        <span id="secondTownFood">100</span>
      </div>
      <div class="second-town-resource">
        <div><img src="assets/icons/odun_icon.png" class="resource-icon" alt="Odun">Odun</div>
        <span id="secondTownWood">200</span>
      </div>
      <div class="second-town-resource">
        <div><img src="assets/icons/tas_icon.png" class="resource-icon" alt="Taş">Taş</div>
        <span id="secondTownStone">100</span>
      </div>
      <div class="second-town-resource">
        <div><img src="assets/icons/altin_icon.png" class="resource-icon" alt="Altın">Altın</div>
        <span id="secondTownGold">0</span>
      </div>
    </div>
  </div>

  <div id="tooltip"></div>
  <canvas id="game"></canvas>

  <div id="topbar">
    <div class="res"><img src="assets/icons/et_icon.png" class="resource-icon" alt="Yiyecek"><b>Yiyecek</b> <span id="food">100</span></div>
    <div class="res"><img src="assets/icons/odun_icon.png" class="resource-icon" alt="Odun"><b>Odun</b> <span id="wood">200</span></div>
    <div class="res"><img src="assets/icons/tas_icon.png" class="resource-icon" alt="Taş"><b>Taş</b> <span id="stone">100</span></div>
    <div class="res"><img src="assets/icons/altin_icon.png" class="resource-icon" alt="Altın"><b>Altın</b> <span id="gold">0</span></div>
    <div id="population"><img src="assets/icons/peoples.png" class="resource-icon" alt="Nüfus"><span id="popCur">0</span> / <span id="popMax">0</span></div>
    <div id="menuBtn"><i class="fas fa-bars"></i>Menü</div>
    <div style="margin-left:auto; opacity:.8">RTS Step 6 – Deer Hunting</div>
  </div>

  <aside id="rightpanel">
    <div class="card" id="selectionCard">
      <div class="title">Seçili Nesne</div>
      <div id="selectionInfo">Hiçbir şey seçili değil.</div>
      <div id="healthContainer" style="display:none;">
        <div class="health-text">Sağlık: <span id="healthPercent">100</span>%</div>
        <div class="health-bar-container"><div class="health-bar" id="healthBar" style="width:100%"></div></div>
      </div>
      <div id="woodContainer" style="display:none;">
        <div class="wood-text">Odun: <span id="woodAmount">0</span>/200</div>
        <div class="wood-bar-container"><div class="wood-bar" id="woodBar" style="width:0%"></div></div>
      </div>
      <div id="stoneContainer" style="display:none;">
        <div class="stone-text">Taş: <span id="stoneAmount">0</span>/200</div>
        <div class="stone-bar-container"><div class="stone-bar" id="stoneBar" style="width:0%"></div></div>
      </div>
      <div id="deerHealthContainer" style="display:none;">
        <div class="deer-health-text">Can: <span id="deerHealthAmount">0</span>/200</div>
        <div class="deer-health-bar-container"><div class="deer-health-bar" id="deerHealthBar" style="width:0%"></div></div>
      </div>
      <div id="deerMeatContainer" style="display:none;">
        <div class="deer-meat-text">Et: <span id="deerMeatAmount">0</span>/200</div>
        <div class="deer-meat-bar-container"><div class="deer-meat-bar" id="deerMeatBar" style="width:0%"></div></div>
      </div>
      <div id="constructionContainer" style="display:none;">
        <div class="construction-text">İnşaat: <span id="constructionPercent">0</span>%</div>
        <div class="construction-bar-container"><div class="construction-bar" id="constructionBar" style="width:0%"></div></div>
      </div>
      <div id="workerResourceContainer" style="display:none;">
        <div class="worker-resource"><img src="assets/icons/odun_icon.png" class="resource-icon" alt="Odun">Taşıdığı Odun: <span id="workerWood">0</span></div>
        <div class="worker-resource"><img src="assets/icons/tas_icon.png" class="resource-icon" alt="Taş">Taşıdığı Taş: <span id="workerStone">0</span></div>
        <div class="worker-resource"><img src="assets/icons/et_icon.png" class="resource-icon" alt="Et">Taşıdığı Et: <span id="workerMeat">0</span></div>
      </div>
      <div id="spawnBtnContainer" style="margin-top:8px;"></div>
    </div>
    <div class="card" id="commandCard" style="display:none;">
      <div class="title">Komutlar</div>
      <div class="grid">
        <div class="btn" id="buildBtn"><img src="assets/icons/insa_icon.png" class="btn-icon" alt="İnşa"><div class="btn-text">İnşa</div></div>
        <div class="btn" id="gatherBtn">Topla</div>
        <div class="btn" id="patrolBtn">Devriye</div>
      </div>
      <div id="buildMenu" style="margin-top:8px; display:none;">
        <div class="grid">
          <div class="btn" id="buildHouseBtn"><img src="assets/icons/house_icon.png" class="btn-icon" alt="Ev"><div class="btn-text">Ev</div></div>
          <div class="btn" id="buildLumberhouseBtn"><img src="assets/icons/oduncu_icon.png" class="btn-icon" alt="Oduncu Evi"><div class="btn-text">Oduncu Evi</div></div>
          <div class="btn" id="buildHunterhouseBtn"><img src="assets/icons/avci_evi_icon.png" class="btn-icon" alt="Avcı Evi"><div class="btn-text">Avcı Evi</div></div>
          <div class="btn" id="buildStonehouseBtn"><img src="assets/icons/tas_evi_icon.png" class="btn-icon" alt="Taş Ocağı"><div class="btn-text">Taş Ocağı</div></div>
        </div>
      </div>
    </div>
  </aside>
  
  <div id="hint">WASD veya Ok Tuşları: Kamera • Scroll: Zoom • Sol Fare: Seçim • Sağ Fare: Seçili birimi hedefe gönder • Delete: Seçili binayı sil • ESC: Menü • Mouse Kenar: Harita Kaydırma</div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const loadingScreen = document.getElementById('loadingScreen');
    const progressFill = document.getElementById('progressFill');
    const loadingPercentage = document.getElementById('loadingPercentage');

    let currentMusic = 1, isMusicPlaying = false;
    let musicVolume = 0.5, isMuted = false, soundEffectsEnabled = true, effectsVolume = 0.7;
    let secondTownWorkersCreated = false, lastResourceLogTime = 0;

    const EDGE_SCROLL_MARGIN = 50, EDGE_SCROLL_SPEED = 8;
    const TW = 64, TH = 32, MAP_W = 80, MAP_H = 80, MOVE_SPEED = 2;
    const buildingCosts = {
      'house1': { wood: 50 }, 'house2': { wood: 50 },
      'lumberhouse': { wood: 50 }, 'hunterhouse': { wood: 50 }, 'stonehouse': { wood: 75 }
    };

    let S = {
      buildMode: null, cam: {x:0, y:0, z:1}, mouse: {x:0, y:0, wx:0, wy:0},
      dragging: false, dragStart: {x:0, y:0}, keys: {},
      map: [], walk: [], entities: [], trees: [], stones: [], deer: [],
      selection: new Set(), res: {food:100, wood:200, stone:100, gold:0},
      uid: 0, lastConstructionUpdate: 0, lastSelectedBuilding: null,
      lastResourceUpdate: 0, lastDeerUpdate: 0, shakingTrees: new Set(),
      fogOfWar: [], explored: [], VISION_RANGE: 8,
      secondTownResources: { food: 100, wood: 200, stone: 100, gold: 0 }
    };

    const treeImages = { type1: new Image(), type2: new Image(), type3: new Image() };
    treeImages.type1.src = 'assets/images/trees/tree1.png';
    treeImages.type2.src = 'assets/images/trees/tree2.png';
    treeImages.type3.src = 'assets/images/trees/tree3.png';

    const stoneImages = { type1: new Image(), type2: new Image(), type3: new Image() };
    stoneImages.type1.src = 'assets/images/stone/stone1.png';
    stoneImages.type2.src = 'assets/images/stone/stone2.png';
    stoneImages.type3.src = 'assets/images/stone/stone3.png';

    const deerImages = { alive: new Image(), dead: new Image() };
    deerImages.alive.src = 'assets/images/deer/deer.png';
    deerImages.dead.src = 'assets/images/deer/dead_deer.png';

    const buildingImages = {
      town: new Image(), town2: new Image(), house1: new Image(), house2: new Image(),
      lumberhouse: new Image(), hunterhouse: new Image(), stonehouse: new Image()
    };
    buildingImages.town.src = 'assets/images/build/ana_ev.png';
    buildingImages.town2.src = 'assets/images/build/ana_ev2.png';
    buildingImages.house1.src = 'assets/images/build/house1.png';
    buildingImages.house2.src = 'assets/images/build/house2.png';
    buildingImages.lumberhouse.src = 'assets/images/build/oduncu.png';
    buildingImages.hunterhouse.src = 'assets/images/build/avci_evi.png';
    buildingImages.stonehouse.src = 'assets/images/build/tas_evi.png';

    // İŞÇİ GÖRSELLERİ EKLENDİ
    const workerImages = {
        man: new Image(),
        woman: new Image()
    };
    workerImages.man.src = 'assets/images/settlers/man.png';
    workerImages.woman.src = 'assets/images/settlers/woman.png';

    function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function randomFloat(min, max) { return Math.random() * (max - min) + min; }
    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    function nextId() { S.uid += 1; return S.uid; }

    function isoToScreen(wx, wy) {
      const x = (wx - wy) * (TW/2) * S.cam.z + canvas.width/2 - S.cam.x;
      const y = (wx + wy) * (TH/2) * S.cam.z + canvas.height/2 - S.cam.y;
      return {x, y};
    }

    function screenToIsoWorld(sx, sy) {
      const cx = sx - canvas.width/2 + S.cam.x;
      const cy = sy - canvas.height/2 + S.cam.y;
      const wx = ((cx/S.cam.z)/(TW/2) + (cy/S.cam.z)/(TH/2)) / 2;
      const wy = ((cy/S.cam.z)/(TH/2) - (cx/S.cam.z)/(TW/2)) / 2;
      return {wx, wy};
    }

    function playSoundEffect(soundId) {
      if (!soundEffectsEnabled) return;
      const sound = document.getElementById(soundId);
      if (sound) {
        sound.volume = effectsVolume;
        sound.currentTime = 0;
        sound.play().catch(err => console.log("Ses efekti çalınamadı:", err));
      }
    }

    function updateVolume() {
      const music1 = document.getElementById('themeMusic1');
      const music2 = document.getElementById('themeMusic2');
      if (music1 && music2) {
        music1.volume = isMuted ? 0 : musicVolume;
        music2.volume = isMuted ? 0 : musicVolume;
      }
    }

    function startGameMusic() {
      if (isMusicPlaying) return;
      isMusicPlaying = true;
      const music1 = document.getElementById('themeMusic1');
      const music2 = document.getElementById('themeMusic2');
      
      music1.volume = isMuted ? 0 : musicVolume;
      music2.volume = isMuted ? 0 : musicVolume;
      
      music1.play().catch(err => console.log("Müzik çalma hatası:", err));
      
      music1.addEventListener('ended', () => { currentMusic = 2; music2.play(); });
      music2.addEventListener('ended', () => { currentMusic = 1; music1.play(); });
    }

    function setupMenu() {
      document.getElementById('menuBtn').onclick = openMenu;
      document.getElementById('resumeBtn').onclick = closeMenu;
      document.getElementById('newGameBtn').onclick = () => { if (confirm('Yeni oyun başlatmak istediğinize emin misiniz?')) location.reload(); };
      document.getElementById('saveBtn').onclick = saveGame;
      document.getElementById('loadBtn').onclick = loadGame;
      document.getElementById('settingsBtn').onclick = () => { document.getElementById('mainMenu').style.display = 'none'; document.getElementById('settingsMenu').style.display = 'block'; };
      document.getElementById('backToMainBtn').onclick = () => { document.getElementById('settingsMenu').style.display = 'none'; document.getElementById('mainMenu').style.display = 'block'; };
      
      document.getElementById('menuVolumeSlider').oninput = function() {
        musicVolume = this.value / 100;
        updateVolume();
        document.getElementById('menuVolumePercent').textContent = this.value + '%';
      };
      
      document.getElementById('muteToggleBtn').onclick = () => {
        isMuted = !isMuted;
        soundEffectsEnabled = !isMuted;
        updateVolume();
        const icon = document.getElementById('muteToggleBtn').querySelector('i');
        icon.className = isMuted ? 'fas fa-volume-mute' : 'fas fa-volume-up';
        document.getElementById('muteToggleBtn').innerHTML = isMuted ? '<i class="fas fa-volume-mute"></i> Sesi Aç' : '<i class="fas fa-volume-up"></i> Sesi Kapat';
      };
      
      document.addEventListener('keydown', e => { if (e.key === 'Escape') document.getElementById('menuOverlay').style.display === 'flex' ? closeMenu() : openMenu(); });
      document.getElementById('menuOverlay').onclick = e => { if (e.target.id === 'menuOverlay') closeMenu(); };
    }

    function openMenu() {
      document.getElementById('menuOverlay').style.display = 'flex';
      document.getElementById('mainMenu').style.display = 'block';
      document.getElementById('settingsMenu').style.display = 'none';
      document.getElementById('menuVolumeSlider').value = musicVolume * 100;
      document.getElementById('menuVolumePercent').textContent = Math.round(musicVolume * 100) + '%';
    }

    function closeMenu() { document.getElementById('menuOverlay').style.display = 'none'; }

    function saveGame() {
      const gameData = {
        resources: S.res, entities: S.entities, trees: S.trees, stones: S.stones, deer: S.deer,
        fogOfWar: S.fogOfWar, explored: S.explored, secondTownResources: S.secondTownResources,
        secondTownWorkersCreated: secondTownWorkersCreated, timestamp: Date.now()
      };
      localStorage.setItem('villagerSave', JSON.stringify(gameData));
      alert('Oyun kaydedildi!');
      closeMenu();
    }

    function loadGame() {
      const saved = localStorage.getItem('villagerSave');
      if (!saved) { alert('Kayıtlı oyun bulunamadı!'); return; }
      try {
        const gameData = JSON.parse(saved);
        S.res = gameData.resources;
        S.entities = gameData.entities;
        S.trees = gameData.trees;
        S.stones = gameData.stones;
        S.deer = gameData.deer;
        S.fogOfWar = gameData.fogOfWar || [];
        S.explored = gameData.explored || [];
        S.secondTownResources = gameData.secondTownResources || { food: 100, wood: 200, stone: 100, gold: 0 };
        secondTownWorkersCreated = gameData.secondTownWorkersCreated || false;
        
        // Eski kayıtlardaki işçilere workerType ata
        S.entities.forEach(e => {
          if (e.kind === 'worker' && !e.workerType) {
            e.workerType = randomInt(1, 2) === 1 ? 'man' : 'woman';
            // Yeni: Eski işçilere devriye özelliklerini ekle
            e.isPatrolling = e.isPatrolling || false;
            e.explorationTargets = e.explorationTargets || [];
            e.currentTargetIndex = e.currentTargetIndex || 0;
          }
        });
        
        updateTopBar();
        updatePopulation();
        updateSecondTownPanel();
        S.selection.clear();
        updateSelectionCard();
        alert('Oyun yüklendi!');
        closeMenu();
      } catch (error) {
        alert('Oyun yüklenirken hata oluştu: ' + error.message);
      }
    }

    function centerCameraOnTown() {
      const townCenter = { x: 10, y: 10 };
      const screenCenter = isoToScreen(townCenter.x, townCenter.y);
      S.cam.x = screenCenter.x - canvas.width / 2;
      S.cam.y = screenCenter.y - canvas.height / 2;
    }

    function updateEdgeScroll() {
      const mx = S.mouse.x, my = S.mouse.y;
      if (mx < 0 || mx > canvas.width || my < 0 || my > canvas.height || loadingScreen.style.display !== 'none') return;
      
      let sx = 0, sy = 0;
      if (mx < EDGE_SCROLL_MARGIN) sx = -EDGE_SCROLL_SPEED;
      else if (mx > canvas.width - EDGE_SCROLL_MARGIN) sx = EDGE_SCROLL_SPEED;
      if (my < EDGE_SCROLL_MARGIN) sy = -EDGE_SCROLL_SPEED;
      else if (my > canvas.height - EDGE_SCROLL_MARGIN) sy = EDGE_SCROLL_SPEED;
      
      S.cam.x += sx;
      S.cam.y += sy;
    }

    function generateTrees() {
      S.trees = [];
      const TOWN_SAFE_RADIUS = 5, TOWN_X = 10, TOWN_Y = 10;
      const clusters = 12;
      
      for (let i = 0; i < clusters; i++) {
        let clusterX, clusterY, attempts = 0;
        do {
          clusterX = randomInt(3, MAP_W - 4);
          clusterY = randomInt(3, MAP_H - 4);
          attempts++;
        } while (Math.hypot(clusterX - TOWN_X, clusterY - TOWN_Y) < TOWN_SAFE_RADIUS && attempts < 50);
        
        const clusterSize = randomInt(30, 50);
        for (let j = 0; j < clusterSize; j++) {
          const x = clusterX + randomInt(-3, 3);
          const y = clusterY + randomInt(-3, 3);
          if (x >= 2 && x < MAP_W - 2 && y >= 2 && y < MAP_H - 2 && Math.hypot(x - TOWN_X, y - TOWN_Y) >= TOWN_SAFE_RADIUS) {
            const tooClose = S.trees.some(tree => Math.abs(tree.x - x) < 1 && Math.abs(tree.y - y) < 1);
            if (!tooClose) S.trees.push({ x, y, type: randomInt(1, 3), wood: 200, choppingWorkers: [] });
          }
        }
      }
      
      for (let i = 0; i < 80; i++) {
        let x, y, attempts = 0;
        do {
          x = randomInt(2, MAP_W - 3);
          y = randomInt(2, MAP_H - 3);
          attempts++;
        } while (Math.hypot(x - TOWN_X, y - TOWN_Y) < TOWN_SAFE_RADIUS && attempts < 50);
        
        const tooClose = S.trees.some(tree => Math.abs(tree.x - x) < 2 && Math.abs(tree.y - y) < 2);
        if (!tooClose) S.trees.push({ x, y, type: randomInt(1, 3), wood: 200, choppingWorkers: [] });
      }
    }

    function generateStones() {
      S.stones = [];
      const TOWN_SAFE_RADIUS = 5, TOWN_X = 10, TOWN_Y = 10;
      
      for (let i = 0; i < 4; i++) {
        let placed = false, attempts = 0;
        while (!placed && attempts < 100) {
          const x = randomInt(3, MAP_W - 4);
          const y = randomInt(3, MAP_H - 4);
          const tooCloseToTown = Math.hypot(x - TOWN_X, y - TOWN_Y) < TOWN_SAFE_RADIUS;
          const tooCloseToTree = S.trees.some(tree => Math.abs(tree.x - x) < 3 && Math.abs(tree.y - y) < 3);
          const tooCloseToOther = S.stones.some(stone => Math.abs(stone.x - x) < 5 && Math.abs(stone.y - y) < 5);
          
          if (!tooCloseToTown && !tooCloseToTree && !tooCloseToOther) {
            S.stones.push({ x, y, type: randomInt(1, 3), stone: 200, miningWorkers: [] });
            placed = true;
          }
          attempts++;
        }
      }
    }

    function generateDeer() {
      S.deer = [];
      const herdCount = 5, deerPerHerd = 5;
      const TOWN_SAFE_RADIUS = 6, TOWN_X = 10, TOWN_Y = 10;
      
      for (let herd = 0; herd < herdCount; herd++) {
        let placed = false, attempts = 0;
        while (!placed && attempts < 100) {
          const cx = randomInt(8, MAP_W - 9);
          const cy = randomInt(8, MAP_H - 9);
          const tooCloseToTown = Math.hypot(cx - TOWN_X, cy - TOWN_Y) < TOWN_SAFE_RADIUS;
          const tooCloseToTree = S.trees.some(t => Math.abs(t.x - cx) < 4 && Math.abs(t.y - cy) < 4);
          const tooCloseToStone = S.stones.some(s => Math.abs(s.x - cx) < 4 && Math.abs(s.y - cy) < 4);
          const tooCloseToHerd = S.deer.some(d => Math.abs(d.herdCenterX - cx) < 10 && Math.abs(d.herdCenterY - cy) < 10);
          
          if (!tooCloseToTown && !tooCloseToTree && !tooCloseToStone && !tooCloseToHerd) {
            for (let i = 0; i < deerPerHerd; i++) {
              const radius = 4;
              const x = cx + randomFloat(-radius, radius);
              const y = cy + randomFloat(-radius, radius);
              S.deer.push({
                id: nextId(), 
                x: Math.max(1, Math.min(MAP_W-1, x)), 
                y: Math.max(1, Math.min(MAP_H-1, y)),
                herdCenterX: cx, 
                herdCenterY: cy, 
                wanderRadius: radius, 
                tx: x, 
                ty: y,
                state: 'idle', 
                stateTimer: randomInt(5000, 10000), 
                speed: 0.5, 
                lastMoveTime: 0,
                health: 200, 
                maxHealth: 200, 
                meat: 200, 
                maxMeat: 200, 
                huntingWorkers: [],
                isFleeing: false, 
                normalState: 'idle', 
                isDead: false, 
                direction: 1
              });
            }
            placed = true;
          }
          attempts++;
        }
      }
    }

    function addSecondTown() {
      let placed = false, attempts = 0;
      while (!placed && attempts < 100) {
        const x = MAP_W - 10, y = MAP_H - 10;
        const tooCloseToTree = S.trees.some(tree => Math.abs(tree.x - x) < 5 && Math.abs(tree.y - y) < 5);
        const tooCloseToStone = S.stones.some(stone => Math.abs(stone.x - x) < 5 && Math.abs(stone.y - y) < 5);
        const tooCloseToDeer = S.deer.some(deer => Math.abs(deer.x - x) < 8 && Math.abs(deer.y - y) < 8);
        
        if (!tooCloseToTree && !tooCloseToStone && !tooCloseToDeer) {
          S.entities.push({
            id: nextId(), kind: 'town2', x, y, health: 100, maxHealth: 100,
            constructionProgress: 100, isUnderConstruction: false, owner: 'secondTown'
          });
          placed = true;
        }
        attempts++;
      }
    }

    function initFogOfWar() {
      S.fogOfWar = [];
      S.explored = [];
      for(let y = 0; y < MAP_H; y++) {
        S.fogOfWar[y] = [];
        S.explored[y] = [];
        for(let x = 0; x < MAP_W; x++) {
          S.fogOfWar[y][x] = true;
          S.explored[y][x] = false;
        }
      }
      
      const TOWN_X = 10, TOWN_Y = 10;
      for(let y = TOWN_Y - 5; y <= TOWN_Y + 5; y++) {
        for(let x = TOWN_X - 5; x <= TOWN_X + 5; x++) {
          if(x >= 0 && x < MAP_W && y >= 0 && y < MAP_H) {
            S.fogOfWar[y][x] = false;
            S.explored[y][x] = true;
          }
        }
      }
    }

    function updateFogOfWar() {
      for(let y = 0; y < MAP_H; y++) {
        for(let x = 0; x < MAP_W; x++) {
          if(S.explored[y][x]) S.fogOfWar[y][x] = true;
        }
      }
      
      S.entities.forEach(e => {
        if(e.kind === 'worker' || ((e.kind === 'town' || e.kind === 'house1' || e.kind === 'house2' || 
            e.kind === 'lumberhouse' || e.kind === 'hunterhouse' || e.kind === 'stonehouse') && 
            !e.isUnderConstruction && !e.owner)) {
          updateVisionAt(e.x, e.y);
        }
      });
    }

    function updateVisionAt(cx, cy) {
      const range = S.VISION_RANGE;
      for(let y = Math.max(0, Math.floor(cy - range)); y <= Math.min(MAP_H-1, Math.floor(cy + range)); y++) {
        for(let x = Math.max(0, Math.floor(cx - range)); x <= Math.min(MAP_W-1, Math.floor(cx + range)); x++) {
          if(Math.hypot(x - cx, y - cy) <= range) {
            S.fogOfWar[y][x] = false;
            S.explored[y][x] = true;
          }
        }
      }
    }

    function findNearest(x, y, array, filter) {
      const filtered = array.filter(filter);
      if (filtered.length === 0) return null;
      return filtered.reduce((nearest, item) => {
        const dist = Math.hypot(item.x - x, item.y - y);
        const nearestDist = Math.hypot(nearest.x - x, nearest.y - y);
        return dist < nearestDist ? item : nearest;
      });
    }

    function findNearestWorker(x, y) {
      const result = findNearest(x, y, S.entities, e => e.kind === 'worker');
      return result ? { worker: result, distance: Math.hypot(result.x - x, result.y - y) } : null;
    }

    function findNearestTree(x, y) { return findNearest(x, y, S.trees, t => t.wood > 0); }
    function findNearestStone(x, y) { return findNearest(x, y, S.stones, s => s.stone > 0); }
    function findNearestDeer(x, y) { return findNearest(x, y, S.deer, d => !d.isDead); }
    function findNearestDeadDeer(x, y) { return findNearest(x, y, S.deer, d => d.isDead && d.meat > 0); }

    function findNearestStorage(x, y, resourceType) {
      return findNearest(x, y, S.entities, e => 
        !e.owner && !e.isUnderConstruction && (
          e.kind === 'town' || 
          (resourceType === 'wood' && e.kind === 'lumberhouse') ||
          (resourceType === 'stone' && e.kind === 'stonehouse') ||
          (resourceType === 'food' && e.kind === 'hunterhouse')
        )
      );
    }

    function findNearestSecondTownStorage(x, y, resourceType) {
      return findNearest(x, y, S.entities, e => 
        e.owner === 'secondTown' && !e.isUnderConstruction && (
          e.kind === 'town2' || 
          (resourceType === 'wood' && e.kind === 'lumberhouse') ||
          (resourceType === 'stone' && e.kind === 'stonehouse') ||
          (resourceType === 'food' && e.kind === 'hunterhouse')
        )
      ) || S.entities.find(e => e.kind === 'town2' && e.owner === 'secondTown');
    }

    function clearWorkerTasks(worker) {
        console.log(`İşçi ${worker.id} görevleri temizleniyor...`);

        // Devriye modunu temizle
        worker.isPatrolling = false;
        worker.explorationTargets = [];
        worker.currentTargetIndex = 0;
        
        // Ağaç kesme görevini temizle - NULL/UNDEFINED KONTROLÜ EKLENDİ
        if (worker.isChopping && worker.isChopping.choppingWorkers) {
            const tree = worker.isChopping;
            tree.choppingWorkers = tree.choppingWorkers.filter(id => id !== worker.id);
            worker.isChopping = null;
        }
        
        // Taş çıkarma görevini temizle - NULL/UNDEFINED KONTROLÜ EKLENDİ
        if (worker.isMining && worker.isMining.miningWorkers) {
            const stone = worker.isMining;
            stone.miningWorkers = stone.miningWorkers.filter(id => id !== worker.id);
            worker.isMining = null;
        }
        
        // Geyik avlama görevini temizle - NULL/UNDEFINED KONTROLÜ EKLENDİ
        if (worker.isHunting && worker.isHunting.huntingWorkers) {
            const deer = worker.isHunting;
            deer.huntingWorkers = deer.huntingWorkers.filter(id => id !== worker.id);
            worker.isHunting = null;
        }
        
        // Diğer görevleri temizle
        worker.isCollectingMeat = null;
        worker.isDelivering = false;
        worker.isDeliveringToBuilding = null;
        
        // İnşaat görevini temizle - NULL/UNDEFINED KONTROLÜ EKLENDİ
        if (worker.isConstructing) {
            const building = S.entities.find(b => b.id === worker.isConstructing);
            if (building && building.constructionWorkers) {
                building.constructionWorkers = building.constructionWorkers.filter(id => id !== worker.id);
            }
            worker.isConstructing = null;
        }
        
        console.log(`İşçi ${worker.id} artık boşta`);
    }

        function startPatrol(workers) {
        if (!workers || workers.length === 0) return;
        
        workers.forEach(worker => {
            // Önceki görevleri temizle
            clearWorkerTasks(worker);
            
            // Devriye modunu aktif et
            worker.isPatrolling = true;
            worker.explorationTargets = [];
            worker.currentTargetIndex = 0;
            
            // Keşfedilmemiş noktaları bul
            findUnexploredAreas(worker);
        });
    }

    function findUnexploredAreas(worker) {
        const unexploredPoints = [];
        const GRID_SIZE = 4; // Performans için ızgara sistemi
        
        for (let y = 0; y < MAP_H; y += GRID_SIZE) {
            for (let x = 0; x < MAP_W; x += GRID_SIZE) {
                // Bu bölgede keşfedilmemiş alan var mı kontrol et
                let hasUnexplored = false;
                for (let dy = 0; dy < GRID_SIZE && y + dy < MAP_H; dy++) {
                    for (let dx = 0; dx < GRID_SIZE && x + dx < MAP_W; dx++) {
                        if (!S.explored[y + dy][x + dx]) {
                            hasUnexplored = true;
                            break;
                        }
                    }
                    if (hasUnexplored) break;
                }
                
                if (hasUnexplored) {
                    unexploredPoints.push({ x: x + GRID_SIZE/2, y: y + GRID_SIZE/2 });
                }
            }
        }
        
        if (unexploredPoints.length === 0) {
            // Tüm harita keşfedilmiş
            worker.isPatrolling = false;
            worker.tx = worker.x;
            worker.ty = worker.y;
            console.log("Tüm harita keşfedildi!");
            return;
        }
        
        // Noktaları işçiye yakınlığına göre sırala
        unexploredPoints.sort((a, b) => {
            const distA = Math.hypot(a.x - worker.x, a.y - worker.y);
            const distB = Math.hypot(b.x - worker.x, b.y - worker.y);
            return distA - distB;
        });
        
        // İlk 20 noktayı hedef olarak al (performans için)
        worker.explorationTargets = unexploredPoints.slice(0, 20);
        worker.currentTargetIndex = 0;
        
        // İlk hedefe git
        moveToNextExplorationTarget(worker);
    }

    function moveToNextExplorationTarget(worker) {
        if (!worker.isPatrolling || worker.explorationTargets.length === 0) return;
        
        // Mevcut hedefi al
        const target = worker.explorationTargets[worker.currentTargetIndex];
        worker.tx = target.x;
        worker.ty = target.y;
        
        console.log(`İşçi ${worker.id} yeni keşif hedefine gidiyor: (${target.x}, ${target.y})`);
    }

    function updatePatrolBehavior(worker) {
        if (!worker.isPatrolling) return;
        
        // Mevcut hedefe ulaştı mı kontrol et
        const currentTarget = worker.explorationTargets[worker.currentTargetIndex];
        if (currentTarget && Math.hypot(worker.x - currentTarget.x, worker.y - currentTarget.y) < 2) {
            // Bu bölgeyi keşfet
            updateVisionAt(worker.x, worker.y);
            
            // Sonraki hedefe geç
            worker.currentTargetIndex++;
            
            if (worker.currentTargetIndex >= worker.explorationTargets.length) {
                // Tüm hedefler bitmiş, yeni hedefler bul
                findUnexploredAreas(worker);
            } else {
                // Sonraki hedefe git
                moveToNextExplorationTarget(worker);
            }
        }
        
        // Eğer hedef yoksa yeni hedefler bul
        if (worker.explorationTargets.length === 0) {
            findUnexploredAreas(worker);
        }
    }

    function sendWorkersToTree(tree, workers) {
      if (!tree.choppingWorkers) tree.choppingWorkers = [];
      
      workers.forEach(w => {
        w.tx = tree.x; 
        w.ty = tree.y; 
        w.isChopping = tree;
        w.isMining = w.isHunting = w.isCollectingMeat = null; 
        w.isDelivering = false;
        w.carryingWood = w.carryingWood || 0;
        
        if(!tree.choppingWorkers.includes(w.id)) {
          tree.choppingWorkers.push(w.id);
        }
      });
    }

    function sendWorkersToStone(stone, workers) {
      if (!stone.miningWorkers) stone.miningWorkers = [];
      
      workers.forEach(w => {
        w.tx = stone.x; 
        w.ty = stone.y; 
        w.isMining = stone;
        w.isChopping = w.isHunting = w.isCollectingMeat = null; 
        w.isDelivering = false;
        w.carryingStone = w.carryingStone || 0;
        
        if(!stone.miningWorkers.includes(w.id)) {
          stone.miningWorkers.push(w.id);
        }
      });
    }

    function sendWorkersToDeer(deer, workers) {
      // Güvenlik kontrolü
      if (!deer) {
        console.error("Deer is undefined in sendWorkersToDeer!");
        return;
      }
      
      // Deer nesnesinde huntingWorkers array'ini garanti et
      if (!deer.huntingWorkers) {
        deer.huntingWorkers = [];
      }
      
      workers.forEach(w => {
        w.tx = deer.x; 
        w.ty = deer.y; 
        w.isHunting = deer;
        w.isChopping = w.isMining = w.isCollectingMeat = null; 
        w.isDelivering = false;
        w.carryingMeat = w.carryingMeat || 0;
        
        if(!deer.huntingWorkers.includes(w.id)) {
          deer.huntingWorkers.push(w.id);
        }
      });
    }

    function sendWorkersToDeadDeer(deer, workers) {
      workers.forEach(w => {
        w.tx = deer.x; 
        w.ty = deer.y; 
        w.isCollectingMeat = deer;
        w.isChopping = w.isMining = w.isHunting = null; 
        w.isDelivering = false;
        w.carryingMeat = w.carryingMeat || 0;
      });
    }

    function sendWorkersToConstruction(building, workers) {
      workers.forEach(w => {
        w.tx = building.x; 
        w.ty = building.y; 
        w.isConstructing = building.id;
        w.isChopping = w.isMining = w.isHunting = w.isCollectingMeat = null; 
        w.isDelivering = false;
        if(!building.constructionWorkers.includes(w.id)) building.constructionWorkers.push(w.id);
      });
    }

    function sendWorkersToBuilding(building, workers) {
      // Hata önleme - building undefined kontrolü
      if (!building) {
        console.error("Building is undefined!");
        return;
      }
      
      // Sadece aynı sahipli işçileri gönder veya sahipsiz binalara sahipsiz işçileri gönder
      const validWorkers = workers.filter(w => {
        if (building.owner === 'secondTown') {
          return w.owner === 'secondTown';
        } else {
          return !w.owner; // Sahipsiz binalara sahipsiz işçiler
        }
      });
      
      validWorkers.forEach(w => {
        w.tx = building.x; 
        w.ty = building.y; 
        w.isDeliveringToBuilding = building.id;
        w.isChopping = w.isMining = w.isHunting = w.isCollectingMeat = null; 
        w.isDelivering = false;
      });
    }

    function rightClickMove(workers) {
      const {wx, wy} = S.mouse;
      if(!workers || workers.length === 0) return;
      const spacing = 0.8, cols = Math.ceil(Math.sqrt(workers.length));
      const positions = [];
      
      for(let i = 0; i < workers.length; i++) {
        const col = i % cols, row = Math.floor(i / cols);
        let tx = Math.floor(wx + (col - (cols-1)/2) * spacing);
        let ty = Math.floor(wy + (row - (cols-1)/2) * spacing);
        tx = Math.max(0, Math.min(MAP_W-1, tx));
        ty = Math.max(0, Math.min(MAP_H-1, ty));
        positions.push({tx, ty});
      }
      
      workers.forEach((w, i) => {
        w.tx = positions[i].tx; w.ty = positions[i].ty;
        clearWorkerTasks(w);
      });
    }

    function updateDeerBehavior(timestamp) {
      if (!S.lastDeerUpdate) S.lastDeerUpdate = timestamp;
      if (timestamp - S.lastDeerUpdate < 100) return;
      
      S.deer.forEach(deer => {
        if (deer.isDead) {
          deer.state = 'dead'; deer.tx = deer.x; deer.ty = deer.y;
          return;
        }
        
        if (!deer.lastMoveTime) deer.lastMoveTime = timestamp;
        
        const nearestWorker = findNearestWorker(deer.x, deer.y);
        const FLEE_DISTANCE = 8, RETURN_DISTANCE = 12;
        
        if (nearestWorker && nearestWorker.distance < FLEE_DISTANCE && !deer.isFleeing) {
          deer.isFleeing = true;
          deer.normalState = deer.state;
          deer.normalStateTimer = deer.stateTimer;
          
          const angle = Math.atan2(deer.y - nearestWorker.worker.y, deer.x - nearestWorker.worker.x);
          deer.tx = Math.max(1, Math.min(MAP_W-1, deer.x + Math.cos(angle) * 15));
          deer.ty = Math.max(1, Math.min(MAP_H-1, deer.y + Math.sin(angle) * 15));
        } else if (deer.isFleeing && (!nearestWorker || nearestWorker.distance > RETURN_DISTANCE)) {
          deer.isFleeing = false;
          deer.state = deer.normalState;
          deer.stateTimer = deer.normalStateTimer;
          deer.tx = deer.x; deer.ty = deer.y;
        }
        
        if (deer.isFleeing) {
          const dx = deer.tx - deer.x, dy = deer.ty - deer.y, dist = Math.hypot(dx, dy);
          if (dist > 0.1) {
            deer.direction = Math.abs(Math.atan2(dy, dx)) < Math.PI/2 ? 1 : -1;
            deer.x += (dx / dist) * 0.03;
            deer.y += (dy / dist) * 0.03;
          } else {
            deer.tx = deer.x; deer.ty = deer.y;
          }
        } else {
          const timeSince = timestamp - deer.lastMoveTime;
          if (timeSince > deer.stateTimer) {
            if (deer.state === 'idle') {
              deer.state = 'moving';
              deer.stateTimer = randomInt(3000, 6000);
              const angle = Math.random() * Math.PI * 2;
              const distance = randomFloat(2, 5);
              deer.tx = Math.max(1, Math.min(MAP_W-1, deer.herdCenterX + Math.cos(angle) * distance));
              deer.ty = Math.max(1, Math.min(MAP_H-1, deer.herdCenterY + Math.sin(angle) * distance));
            } else {
              deer.state = 'idle';
              deer.stateTimer = randomInt(8000, 15000);
              deer.tx = deer.x; deer.ty = deer.y;
            }
            deer.lastMoveTime = timestamp;
          }
          
          if (deer.state === 'moving') {
            const dx = deer.tx - deer.x, dy = deer.ty - deer.y, dist = Math.hypot(dx, dy);
            if (dist > 0.1) {
              deer.direction = Math.abs(Math.atan2(dy, dx)) < Math.PI/2 ? 1 : -1;
              deer.x += (dx / dist) * deer.speed * 0.03;
              deer.y += (dy / dist) * deer.speed * 0.03;
              
              const distToCenter = Math.hypot(deer.x - deer.herdCenterX, deer.y - deer.herdCenterY);
              if (distToCenter > deer.wanderRadius * 2) {
                const angleToCenter = Math.atan2(deer.herdCenterY - deer.y, deer.herdCenterX - deer.x);
                deer.tx = deer.herdCenterX + Math.cos(angleToCenter) * randomFloat(1, 3);
                deer.ty = deer.herdCenterY + Math.sin(angleToCenter) * randomFloat(1, 3);
              }
            } else {
              deer.state = 'idle';
              deer.stateTimer = randomInt(8000, 15000);
            }
          }
        }
      });
      
      S.lastDeerUpdate = timestamp;
    }

    function createSecondTownWorkers() {
      if (secondTownWorkersCreated) return;
      const secondTown = S.entities.find(e => e.kind === 'town2');
      if (!secondTown) return;
      
      for (let i = 0; i < 2; i++) {
        // RANDOM İŞÇİ TİPİ EKLENDİ
        const workerType = randomInt(1, 2) === 1 ? 'man' : 'woman';
        S.entities.push({
          id: nextId(), 
          kind: 'worker', 
          x: secondTown.x + 0.8 + i * 0.5, 
          y: secondTown.y,
          tx: secondTown.x + 0.8 + i * 0.5, 
          ty: secondTown.y,
          carryingWood: 0, 
          carryingStone: 0, 
          carryingMeat: 0, 
          owner: 'secondTown',
          workerType: workerType  // İŞÇİ TİPİ KAYDEDİLDİ
        });
      }
      secondTownWorkersCreated = true;
      setTimeout(() => assignSecondTownTasks(), 1000);
    }

    function assignSecondTownTasks() {
      const workers = S.entities.filter(w => w.kind === 'worker' && w.owner === 'secondTown');
      workers.forEach(w => {
        if (!w.isConstructing && !w.isChopping && !w.isMining && !w.isHunting && !w.isCollectingMeat && !w.isDelivering) {
          const tree = findNearestTree(w.x, w.y);
          if (tree) { sendWorkersToTree(tree, [w]); return; }
          const stone = findNearestStone(w.x, w.y);
          if (stone) { sendWorkersToStone(stone, [w]); return; }
          const deer = findNearestDeer(w.x, w.y);
          if (deer) { sendWorkersToDeer(deer, [w]); return; }
          const secondTown = S.entities.find(e => e.kind === 'town2' && e.owner === 'secondTown');
          if (secondTown) { w.tx = secondTown.x; w.ty = secondTown.y; }
        }
      });
    }

    function deliverResources(worker, resourceType, amount) {
      if (worker.owner === 'secondTown') {
        S.secondTownResources[resourceType] += amount;
        updateSecondTownPanel(); // 2. Ev panelini güncelle
      } else {
        S.res[resourceType] += amount;
      }
    }

    function updateConstruction(timestamp) {
      S.entities.forEach(building => {
        if(building.isUnderConstruction && building.constructionProgress < 100) {
          const activeWorkers = building.constructionWorkers.filter(id => {
            const worker = S.entities.find(w => w.id === id && w.kind === 'worker');
            return worker && Math.hypot(worker.x - building.x, worker.y - building.y) < 0.5;
          });
          
          if(activeWorkers.length > 0 && timestamp - (building.lastProgressUpdate || 0) > 1000) {
            building.constructionProgress += activeWorkers.length * 10;
            building.constructionProgress = Math.min(building.constructionProgress, 100);
            building.lastProgressUpdate = timestamp;
            
            if(building.constructionProgress >= 100) {
              building.isUnderConstruction = false;
              
              if (building.kind === 'house1' || building.kind === 'house2') playSoundEffect('houseSound');
              else if (building.kind === 'stonehouse') playSoundEffect('stonemasonSound');
              else if (building.kind === 'lumberhouse') playSoundEffect('lumberSound');
              else if (building.kind === 'hunterhouse') playSoundEffect('hunterSound');
              
              activeWorkers.forEach(id => {
                const worker = S.entities.find(w => w.id === id);
                if(worker) {
                  worker.isConstructing = null;
                  if (worker.owner === 'secondTown') setTimeout(() => assignSecondTownTasks(), 100);
                }
              });
              
              building.constructionWorkers = [];
              updatePopulation();
              if (S.lastSelectedBuilding === building.id) updateSelectionCard();
            }
          }
        }
      });
    }

    function updateResourceCollection(timestamp) {
      if(!S.lastResourceUpdate) S.lastResourceUpdate = timestamp;
      if(timestamp - S.lastResourceUpdate < 1000) return;
      
      for (let i = S.trees.length - 1; i >= 0; i--) {
        const tree = S.trees[i];
        
        if (tree.wood > 0 && tree.choppingWorkers.length > 0) {
          const activeWorkers = tree.choppingWorkers.filter(id => {
            const worker = S.entities.find(w => w.id === id && w.kind === 'worker');
            return worker && Math.hypot(worker.x - tree.x, worker.y - tree.y) < 1.5;
          });
          
          if (activeWorkers.length > 0) {
            S.shakingTrees.add(tree);
            setTimeout(() => S.shakingTrees.delete(tree), 200);
          }
        }
        
        if (tree.wood <= 0) {
          S.shakingTrees.delete(tree);
          tree.choppingWorkers.forEach(id => {
            const worker = S.entities.find(w => w.id === id && w.kind === 'worker');
            if (worker) {
              worker.isChopping = null;
              const newTree = findNearestTree(worker.x, worker.y);
              if (newTree) sendWorkersToTree(newTree, [worker]);
              else { worker.tx = worker.x; worker.ty = worker.y; }
            }
          });
          S.trees.splice(i, 1);
          continue;
        }
        
        if(tree.wood > 0 && tree.choppingWorkers.length > 0) {
          const activeWorkers = tree.choppingWorkers.filter(id => {
            const worker = S.entities.find(w => w.id === id && w.kind === 'worker');
            return worker && Math.hypot(worker.x - tree.x, worker.y - tree.y) < 1.5;
          });
          
          if(activeWorkers.length > 0) {
            tree.wood = Math.max(0, tree.wood - activeWorkers.length);
            
            activeWorkers.forEach(id => {
              const worker = S.entities.find(w => w.id === id);
              if(worker) {
                worker.carryingWood = (worker.carryingWood || 0) + 1;
                
                if(worker.carryingWood >= 10 || tree.wood === 0) {
                  const storage = worker.owner === 'secondTown' ? 
                    findNearestSecondTownStorage(worker.x, worker.y, 'wood') :
                    findNearestStorage(worker.x, worker.y, 'wood');
                  if(storage) {
                    worker.isChopping = null;
                    worker.isDelivering = true;
                    worker.tx = storage.x;
                    worker.ty = storage.y;
                    tree.choppingWorkers = tree.choppingWorkers.filter(wid => wid !== id);
                  }
                }
              }
            });
            
            if(S.selection.has('tree_' + i)) updateSelectionCard();
          }
        }
      }
      
      for (let i = S.stones.length - 1; i >= 0; i--) {
        const stone = S.stones[i];
        if (stone.stone <= 0) {
          stone.miningWorkers.forEach(id => {
            const worker = S.entities.find(w => w.id === id && w.kind === 'worker');
            if (worker) {
              worker.isMining = null;
              const newStone = findNearestStone(worker.x, worker.y);
              if (newStone) sendWorkersToStone(newStone, [worker]);
              else { worker.tx = worker.x; worker.ty = worker.y; }
            }
          });
          S.stones.splice(i, 1);
          continue;
        }
        
        if(stone.stone > 0 && stone.miningWorkers.length > 0) {
          const activeWorkers = stone.miningWorkers.filter(id => {
            const worker = S.entities.find(w => w.id === id && w.kind === 'worker');
            return worker && Math.hypot(worker.x - stone.x, worker.y - stone.y) < 1.5;
          });
          
          if(activeWorkers.length > 0) {
            stone.stone = Math.max(0, stone.stone - activeWorkers.length);
            
            activeWorkers.forEach(id => {
              const worker = S.entities.find(w => w.id === id);
              if(worker) {
                worker.carryingStone = (worker.carryingStone || 0) + 1;
                
                if(worker.carryingStone >= 10 || stone.stone === 0) {
                  const storage = worker.owner === 'secondTown' ?
                    findNearestSecondTownStorage(worker.x, worker.y, 'stone') :
                    findNearestStorage(worker.x, worker.y, 'stone');
                  if(storage) {
                    worker.isMining = null;
                    worker.isDelivering = true;
                    worker.tx = storage.x;
                    worker.ty = storage.y;
                    stone.miningWorkers = stone.miningWorkers.filter(wid => wid !== id);
                  }
                }
              }
            });
            
            if(S.selection.has('stone_' + i)) updateSelectionCard();
          }
        }
      }
      
      S.deer.forEach((deer, idx) => {
        if (deer.health <= 0 && !deer.isDead) {
          deer.isDead = true;
          deer.state = 'dead';
          deer.isFleeing = false;
          
          deer.huntingWorkers.forEach(id => {
            const worker = S.entities.find(w => w.id === id && w.kind === 'worker');
            if (worker) {
              worker.isHunting = null;
              worker.isCollectingMeat = deer;
              worker.tx = deer.x;
              worker.ty = deer.y;
            }
          });
          
          if(S.selection.has('deer_' + idx)) updateSelectionCard();
        }
        
        if(deer.health > 0 && deer.huntingWorkers.length > 0) {
          deer.huntingWorkers.forEach(id => {
            const worker = S.entities.find(w => w.id === id && w.kind === 'worker');
            if (worker && worker.isHunting === deer) {
              const dist = Math.hypot(worker.x - deer.x, worker.y - deer.y);
              if (dist > 1.5 || Math.abs(worker.tx - deer.x) > 0.5 || Math.abs(worker.ty - deer.y) > 0.5) {
                worker.tx = deer.x;
                worker.ty = deer.y;
              }
              if(dist < 1.5) deer.health = Math.max(0, deer.health - 20);
            }
          });
          
          if(S.selection.has('deer_' + idx)) updateSelectionCard();
        }
        
        if(deer.isDead && deer.meat > 0) {
          S.entities.forEach(worker => {
            if(worker.kind === 'worker' && worker.isCollectingMeat === deer) {
              worker.tx = deer.x;
              worker.ty = deer.y;
              
              if(Math.hypot(worker.x - deer.x, worker.y - deer.y) < 1.5) {
                const meatToCollect = Math.min(10, deer.meat);
                deer.meat -= meatToCollect;
                worker.carryingMeat = (worker.carryingMeat || 0) + meatToCollect;
                
                if(deer.meat === 0) {
                  const storage = worker.owner === 'secondTown' ?
                    findNearestSecondTownStorage(worker.x, worker.y, 'food') :
                    findNearestStorage(worker.x, worker.y, 'food');
                  if(storage) {
                    worker.isCollectingMeat = null;
                    worker.isDelivering = true;
                    worker.tx = storage.x;
                    worker.ty = storage.y;
                  }
                  setTimeout(() => {
                    const index = S.deer.indexOf(deer);
                    if (index > -1) S.deer.splice(index, 1);
                  }, 1000);
                }
                
                if(S.selection.has('deer_' + idx)) updateSelectionCard();
              }
            }
          });
        }
      });
      
      S.entities.forEach(worker => {
        if(worker.kind === 'worker' && worker.isDeliveringToBuilding) {
          const building = S.entities.find(b => b.id === worker.isDeliveringToBuilding);
          
          if(building && Math.hypot(worker.x - building.x, worker.y - building.y) < 0.5) {
            let delivered = false;
            
            if(worker.owner === building.owner) {
              if(worker.carryingWood > 0 && (building.kind === 'lumberhouse' || building.kind === 'town' || building.kind === 'town2')) {
                deliverResources(worker, 'wood', worker.carryingWood);
                worker.carryingWood = 0;
                delivered = true;
              }
              
              if(worker.carryingStone > 0 && (building.kind === 'stonehouse' || building.kind === 'town' || building.kind === 'town2')) {
                deliverResources(worker, 'stone', worker.carryingStone);
                worker.carryingStone = 0;
                delivered = true;
              }
              
              if(worker.carryingMeat > 0 && (building.kind === 'hunterhouse' || building.kind === 'town' || building.kind === 'town2')) {
                deliverResources(worker, 'food', worker.carryingMeat);
                worker.carryingMeat = 0;
                delivered = true;
              }
            }
            
            if(delivered) {
              worker.isDeliveringToBuilding = null;
              updateTopBar();
              if(S.selection.has(worker.id)) updateSelectionCard();
              if (worker.owner === 'secondTown') setTimeout(() => assignSecondTownTasks(), 100);
            } else {
              worker.isDeliveringToBuilding = null;
            }
          }
        }
      });
      
      S.entities.forEach(worker => {
        if(worker.kind === 'worker' && worker.isDelivering) {
          let storage = null, resourceType = '';
          
          if(worker.carryingWood > 0) {
            storage = worker.owner === 'secondTown' ?
              findNearestSecondTownStorage(worker.x, worker.y, 'wood') :
              findNearestStorage(worker.x, worker.y, 'wood');
            resourceType = 'wood';
          } else if(worker.carryingStone > 0) {
            storage = worker.owner === 'secondTown' ?
              findNearestSecondTownStorage(worker.x, worker.y, 'stone') :
              findNearestStorage(worker.x, worker.y, 'stone');
            resourceType = 'stone';
          } else if(worker.carryingMeat > 0) {
            storage = worker.owner === 'secondTown' ?
              findNearestSecondTownStorage(worker.x, worker.y, 'food') :
              findNearestStorage(worker.x, worker.y, 'food');
            resourceType = 'food';
          }
          
          if(storage && Math.hypot(worker.x - storage.x, worker.y - storage.y) < 0.5) {
            if(worker.carryingWood > 0) {
              deliverResources(worker, 'wood', worker.carryingWood);
              worker.carryingWood = 0;
            }
            if(worker.carryingStone > 0) {
              deliverResources(worker, 'stone', worker.carryingStone);
              worker.carryingStone = 0;
            }
            if(worker.carryingMeat > 0) {
              deliverResources(worker, 'food', worker.carryingMeat);
              worker.carryingMeat = 0;
            }
            
            worker.isDelivering = false;
            updateTopBar();
            if(S.selection.has(worker.id)) updateSelectionCard();
            
            if (worker.owner === 'secondTown') {
              setTimeout(() => assignSecondTownTasks(), 100);
            } else {
              let newResource = null;
              if(resourceType === 'wood') {
                newResource = findNearestTree(worker.x, worker.y);
                if(newResource) sendWorkersToTree(newResource, [worker]);
              } else if(resourceType === 'stone') {
                newResource = findNearestStone(worker.x, worker.y);
                if(newResource) sendWorkersToStone(newResource, [worker]);
              }
              
              if(!newResource) {
                worker.tx = worker.x;
                worker.ty = worker.y;
              }
            }
          }
        }
      });
      
      S.lastResourceUpdate = timestamp;
    }

    function commitSelection() {
      S.selection.clear();
      let minx = Math.min(S.dragStart.x, S.mouse.x), miny = Math.min(S.dragStart.y, S.mouse.y);
      let maxx = Math.max(S.dragStart.x, S.mouse.x), maxy = Math.max(S.dragStart.y, S.mouse.y);
      const dragDist = Math.hypot(maxx - minx, maxy - miny);

      if(dragDist > 8) {
        S.entities.forEach(e => {
          const s = isoToScreen(e.x, e.y);
          if(s.x >= minx && s.x <= maxx && s.y >= miny && s.y <= maxy) S.selection.add(e.id);
        });
        S.deer.forEach((deer, idx) => {
          const s = isoToScreen(deer.x, deer.y);
          if(s.x >= minx && s.x <= maxx && s.y >= miny && s.y <= maxy) S.selection.add('deer_' + idx);
        });
      } else {
        let hit = null, best = 1e9;
        
        for(const entity of S.entities) {
          if(entity.kind === 'town' || entity.kind === 'house1' || entity.kind === 'house2' || 
             entity.kind === 'lumberhouse' || entity.kind === 'hunterhouse' || entity.kind === 'stonehouse') {
            const s = isoToScreen(entity.x, entity.y);
            const d = Math.hypot(S.mouse.x - s.x, S.mouse.y - s.y);
            if(d < 30 && d < best) { best = d; hit = entity; }
          }
        }
        
        if(!hit) {
          for(const tree of S.trees) {
            const s = isoToScreen(tree.x, tree.y);
            const d = Math.hypot(S.mouse.x - s.x, S.mouse.y - s.y);
            if(d < 40 && d < best) { best = d; hit = tree; }
          }
        }
        
        if(!hit) {
          for(const stone of S.stones) {
            const s = isoToScreen(stone.x, stone.y);
            const d = Math.hypot(S.mouse.x - s.x, S.mouse.y - s.y);
            if(d < 40 && d < best) { best = d; hit = stone; }
          }
        }
        
        if(!hit) {
          for(const deer of S.deer) {
            const s = isoToScreen(deer.x, deer.y);
            const d = Math.hypot(S.mouse.x - s.x, S.mouse.y - s.y);
            if(d < 40 && d < best) { best = d; hit = deer; }
          }
        }
        
        if(!hit) {
          for(const e of S.entities) {
            if(e.kind !== 'worker') continue;
            const s = isoToScreen(e.x, e.y);
            const d = Math.hypot(S.mouse.x - s.x, S.mouse.y - s.y);
            if(d < 18 && d < best) { best = d; hit = e; }
          }
        }
        
        if(hit) {
          if(hit.kind) S.selection.add(hit.id);
          else if(hit.wood !== undefined) S.selection.add('tree_' + S.trees.indexOf(hit));
          else if(hit.stone !== undefined) S.selection.add('stone_' + S.stones.indexOf(hit));
          else if(hit.herdCenterX !== undefined) S.selection.add('deer_' + S.deer.indexOf(hit));
        }
      }
      updateSelectionCard();
    }

    function updateSelectionCard() {
      const selInfo = document.getElementById('selectionInfo');
      const spawnContainer = document.getElementById('spawnBtnContainer');
      const commandCard = document.getElementById('commandCard');
      
      ['healthContainer', 'woodContainer', 'stoneContainer', 'deerHealthContainer', 
       'deerMeatContainer', 'constructionContainer', 'workerResourceContainer'].forEach(id => {
        document.getElementById(id).style.display = 'none';
      });
      
      spawnContainer.innerHTML = '';
      commandCard.style.display = 'none';
      S.lastSelectedBuilding = null;
      
      if(!S.selection.size) {
        selInfo.textContent = 'Hiçbir şey seçili değil.';
        return;
      }

      const selectedWorkers = [...S.selection].map(id => S.entities.find(x => x.id === id && x.kind === 'worker')).filter(Boolean);
      const hasSecondTownWorker = selectedWorkers.some(w => w.owner === 'secondTown');
      if(selectedWorkers.length > 0 && !hasSecondTownWorker) commandCard.style.display = 'block';

      if(S.selection.size === 1) {
        const id = [...S.selection][0];
        
        if(typeof id === 'string' && id.startsWith('tree_')) {
          const tree = S.trees[parseInt(id.split('_')[1])];
          if(tree) {
            selInfo.innerHTML = '<div class="selection-header"><img src="assets/icons/agac_icon.png" class="selection-icon"><b>Ağaç</b></div>';
            document.getElementById('woodAmount').textContent = tree.wood;
            document.getElementById('woodBar').style.width = Math.round((tree.wood / 200) * 100) + '%';
            document.getElementById('woodContainer').style.display = 'block';
          }
          return;
        }
        
        if(typeof id === 'string' && id.startsWith('stone_')) {
          const stone = S.stones[parseInt(id.split('_')[1])];
          if(stone) {
            selInfo.innerHTML = '<div class="selection-header"><img src="assets/icons/tas_icon.png" class="selection-icon"><b>Taş Kaynağı</b></div>';
            document.getElementById('stoneAmount').textContent = stone.stone;
            document.getElementById('stoneBar').style.width = Math.round((stone.stone / 200) * 100) + '%';
            document.getElementById('stoneContainer').style.display = 'block';
          }
          return;
        }
        
        if(typeof id === 'string' && id.startsWith('deer_')) {
          const deer = S.deer[parseInt(id.split('_')[1])];
          if(deer) {
            if(deer.isDead) {
              selInfo.innerHTML = '<div class="selection-header"><img src="assets/icons/geyik_icon.png" class="selection-icon"><b>Ölü Geyik</b></div>';
              document.getElementById('deerMeatAmount').textContent = deer.meat;
              document.getElementById('deerMeatBar').style.width = Math.round((deer.meat / deer.maxMeat) * 100) + '%';
              document.getElementById('deerMeatContainer').style.display = 'block';
            } else {
              selInfo.innerHTML = '<div class="selection-header"><img src="assets/icons/geyik_icon.png" class="selection-icon"><b>Geyik</b></div>';
              document.getElementById('deerHealthAmount').textContent = deer.health;
              document.getElementById('deerHealthBar').style.width = Math.round((deer.health / deer.maxHealth) * 100) + '%';
              document.getElementById('deerHealthContainer').style.display = 'block';
            }
          }
          return;
        }
        
        const e = S.entities.find(x => x.id === id);
        if(!e) { selInfo.textContent = '—'; return; }

        if(e.kind === 'worker') {
          let status = 'Boşta';
          if(e.isPatrolling) status = 'Devriyede - Haritayı keşfediyor';
          else if(e.isConstructing) status = 'İnşaatta çalışıyor';
          else if(e.isChopping) status = 'Ağaç kesiyor';
          else if(e.isMining) status = 'Taş çıkarıyor';
          else if(e.isHunting) status = 'Geyik avlıyor';
          else if(e.isCollectingMeat) status = 'Et topluyor';
          else if(e.isDeliveringToBuilding) status = 'Binaya kaynak taşıyor';
          else if(e.isDelivering) status = (e.carryingWood ? 'Odun taşıyor' : e.carryingStone ? 'Taş taşıyor' : 'Et taşıyor');
          
          selInfo.innerHTML = '<div class="selection-header"><img src="assets/icons/isci_icon.png" class="selection-icon"><b>İşçi</b></div>Durum: ' + status;
          document.getElementById('workerWood').textContent = e.carryingWood || 0;
          document.getElementById('workerStone').textContent = e.carryingStone || 0;
          document.getElementById('workerMeat').textContent = e.carryingMeat || 0;
          document.getElementById('workerResourceContainer').style.display = 'block';
        } else if(e.kind === 'town') {
          selInfo.innerHTML = '<div class="selection-header"><img src="assets/icons/ana_ev_icon.png" class="selection-icon"><b>Kasaba Merkezi</b></div>';
          const percent = Math.round((e.health / e.maxHealth) * 100);
          document.getElementById('healthPercent').textContent = percent;
          document.getElementById('healthBar').style.width = percent + '%';
          document.getElementById('healthContainer').style.display = 'block';
          
          const btn = document.createElement('div');
          btn.className = 'btn';
          btn.innerHTML = '<img src="assets/icons/isci_icon.png" class="resource-icon"> İşçi Üret (50 <img src="assets/icons/et_icon.png" class="resource-icon">)';
          btn.onclick = () => {
            const playerWorkers = S.entities.filter(x => x.kind === 'worker' && !x.owner);
            const playerHouses = S.entities.filter(x => (x.kind === 'house1' || x.kind === 'house2') && !x.isUnderConstruction && !x.owner).length;
            const playerMaxPop = 2 + playerHouses * 2;
            
            if(playerWorkers.length >= playerMaxPop) { alert('Ev yapman lazım!'); return; }
            if(S.res.food < 50) { alert('Yeterli yiyecek yok!'); return; }
            S.res.food -= 50;
            
            // RANDOM İŞÇİ TİPİ EKLENDİ
            const workerType = randomInt(1, 2) === 1 ? 'man' : 'woman';
            S.entities.push({ 
              id: nextId(), 
              kind: 'worker', 
              x: e.x + 0.8, 
              y: e.y, 
              tx: e.x + 0.8, 
              ty: e.y,
              carryingWood: 0, 
              carryingStone: 0, 
              carryingMeat: 0,
              workerType: workerType,  // İŞÇİ TİPİ KAYDEDİLDİ
              isPatrolling: false,        // Yeni: Devriye modunda mı?
              explorationTargets: [],     // Yeni: Keşfedilecek noktalar
              currentTargetIndex: 0       // Yeni: Mevcut hedef indeksi
            });
            updateTopBar();
            updatePopulation();
          };
          spawnContainer.appendChild(btn);
        } else {
          const icons = {
            house1: 'house_icon.png', house2: 'house_icon.png',
            lumberhouse: 'oduncu_icon.png', hunterhouse: 'avci_evi_icon.png', stonehouse: 'tas_evi_icon.png'
          };
          const names = {
            house1: 'Ev', house2: 'Ev',
            lumberhouse: 'Oduncu Evi', hunterhouse: 'Avcı Evi', stonehouse: 'Taş Ocağı'
          };
          
          if(icons[e.kind]) {
            selInfo.innerHTML = `<div class="selection-header"><img src="assets/icons/${icons[e.kind]}" class="selection-icon"><b>${names[e.kind]}</b></div>`;
            const percent = Math.round((e.health / e.maxHealth) * 100);
            document.getElementById('healthPercent').textContent = percent;
            document.getElementById('healthBar').style.width = percent + '%';
            document.getElementById('healthContainer').style.display = 'block';
            
            if(e.isUnderConstruction) {
              document.getElementById('constructionPercent').textContent = Math.round(e.constructionProgress);
              document.getElementById('constructionBar').style.width = e.constructionProgress + '%';
              document.getElementById('constructionContainer').style.display = 'block';
              S.lastSelectedBuilding = e.id;
            }
          }
        }
      } else {
        selInfo.innerHTML = `<div class="selection-header"><img src="assets/icons/isci_icon.png" class="selection-icon"><b>${S.selection.size} birim seçili</b></div>`;
      }
    }

    function updateTopBar() {
      document.getElementById('food').textContent = S.res.food;
      document.getElementById('wood').textContent = S.res.wood;
      document.getElementById('stone').textContent = S.res.stone;
      document.getElementById('gold').textContent = S.res.gold;
      updatePopulation();
    }

    function updateSecondTownPanel() {
      document.getElementById('secondTownFood').textContent = S.secondTownResources.food;
      document.getElementById('secondTownWood').textContent = S.secondTownResources.wood;
      document.getElementById('secondTownStone').textContent = S.secondTownResources.stone;
      document.getElementById('secondTownGold').textContent = S.secondTownResources.gold;
    }

    function updatePopulation() {
      const playerWorkers = S.entities.filter(x => x.kind === 'worker' && !x.owner);
      const playerHouses = S.entities.filter(x => (x.kind === 'house1' || x.kind === 'house2') && !x.isUnderConstruction && !x.owner).length;
      const playerMaxPop = 2 + playerHouses * 2;
      
      document.getElementById('popCur').textContent = playerWorkers.length;
      document.getElementById('popMax').textContent = playerMaxPop;
    }

    function deleteSelectedBuilding() {
      if (S.selection.size !== 1) return;
      const selectedEntity = S.entities.find(e => e.id === [...S.selection][0]);
      
      if (selectedEntity && (selectedEntity.kind === 'house1' || selectedEntity.kind === 'house2' || 
          selectedEntity.kind === 'lumberhouse' || selectedEntity.kind === 'hunterhouse' || selectedEntity.kind === 'stonehouse')) {
        
        let refund = 0;
        if (selectedEntity.kind === 'house1' || selectedEntity.kind === 'house2' || 
            selectedEntity.kind === 'lumberhouse' || selectedEntity.kind === 'hunterhouse') refund = 25;
        else if (selectedEntity.kind === 'stonehouse') refund = 37;
        
        S.res.wood += refund;
        S.entities = S.entities.filter(e => e.id !== selectedEntity.id);
        S.selection.clear();
        updateTopBar();
        updatePopulation();
        updateSelectionCard();
      }
    }

    // 2. Ev Panel Kontrolleri
    function setupSecondTownPanel() {
      const toggle = document.getElementById('secondTownToggle');
      const panel = document.getElementById('secondTownPanel');
      
      toggle.addEventListener('click', () => {
        panel.classList.toggle('collapsed');
        const icon = toggle.querySelector('i');
        if (panel.classList.contains('collapsed')) {
          icon.className = 'fas fa-chevron-up';
          toggle.innerHTML = '<i class="fas fa-chevron-up"></i> 2. Ev Kaynakları';
        } else {
          icon.className = 'fas fa-chevron-down';
          toggle.innerHTML = '<i class="fas fa-chevron-down"></i> 2. Ev Kaynakları';
        }
      });
    }

    for(let y = 0; y < MAP_H; y++) {
      S.map[y] = []; S.walk[y] = [];
      for(let x = 0; x < MAP_W; x++) { S.map[y][x] = 0; S.walk[y][x] = true; }
    }

    S.entities.push({ id: 1, kind: 'town', x: 10, y: 10, health: 100, maxHealth: 100, constructionProgress: 100, isUnderConstruction: false });
    addSecondTown();
    generateTrees();
    generateStones();
    generateDeer();
    initFogOfWar();

    // Başlangıçtaki işçilere workerType ata
    S.entities.forEach(e => {
      if (e.kind === 'worker' && !e.workerType) {
        e.workerType = randomInt(1, 2) === 1 ? 'man' : 'woman';
      }
    });

    S.uid = Math.max(S.uid, ...S.entities.map(e => e.id), ...S.deer.map(d => d.id));

    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('keydown', e => {
      const key = e.key.toLowerCase();
      S.keys[key] = true;
      if (e.key === 'ArrowUp') S.keys['arrowup'] = true;
      if (e.key === 'ArrowDown') S.keys['arrowdown'] = true;
      if (e.key === 'ArrowLeft') S.keys['arrowleft'] = true;
      if (e.key === 'ArrowRight') S.keys['arrowright'] = true;
      if (e.key === 'Delete') deleteSelectedBuilding();
    });

    window.addEventListener('keyup', e => {
      const key = e.key.toLowerCase();
      S.keys[key] = false;
      if (e.key === 'ArrowUp') S.keys['arrowup'] = false;
      if (e.key === 'ArrowDown') S.keys['arrowdown'] = false;
      if (e.key === 'ArrowLeft') S.keys['arrowleft'] = false;
      if (e.key === 'ArrowRight') S.keys['arrowright'] = false;
    });

    canvas.addEventListener('mousemove', e => {
      S.mouse.x = e.clientX; S.mouse.y = e.clientY;
      const {wx, wy} = screenToIsoWorld(e.clientX, e.clientY);
      S.mouse.wx = wx; S.mouse.wy = wy;
    });

    canvas.addEventListener('mousedown', e => {
      if(e.button === 0) {
        if(S.buildMode) {
          const x = Math.floor(S.mouse.wx), y = Math.floor(S.mouse.wy);
          
          let canBuild = true;
          for(const entity of S.entities) {
            if((entity.kind === 'town' || entity.kind === 'house1' || entity.kind === 'house2' || 
               entity.kind === 'lumberhouse' || entity.kind === 'hunterhouse' || entity.kind === 'stonehouse') &&
               Math.floor(entity.x) === x && Math.floor(entity.y) === y) {
              canBuild = false; break;
            }
          }
          
          if(canBuild) {
            for(const tree of S.trees) {
              if(Math.floor(tree.x) === x && Math.floor(tree.y) === y) { canBuild = false; break; }
            }
          }
          
          if(canBuild) {
            for(const stone of S.stones) {
              if(Math.floor(stone.x) === x && Math.floor(stone.y) === y) { canBuild = false; break; }
            }
          }
          
          if(canBuild) {
            for(const deer of S.deer) {
              if(Math.floor(deer.x) === x && Math.floor(deer.y) === y) { canBuild = false; break; }
            }
          }
          
          const cost = (S.buildMode === 'house1' || S.buildMode === 'house2' || 
                       S.buildMode === 'lumberhouse' || S.buildMode === 'hunterhouse') ? 50 : 75;
          
          if(canBuild && S.res.wood >= cost) {
            const newBuilding = {
              id: nextId(), kind: S.buildMode, x, y, health: 100, maxHealth: 100,
              constructionProgress: 0, isUnderConstruction: true, constructionWorkers: []
            };
            S.entities.push(newBuilding);
            S.res.wood -= cost;
            updateTopBar();
            playSoundEffect('buildSound');
            
            const nearestWorker = S.entities.filter(w => w.kind === 'worker' && !w.owner &&
              !w.isConstructing && !w.isChopping && !w.isMining && !w.isHunting && 
              !w.isCollectingMeat && !w.isDelivering && !w.isDeliveringToBuilding)
              .reduce((nearest, w) => {
                if (!nearest) return w;
                const d1 = Math.hypot(w.x - x, w.y - y);
                const d2 = Math.hypot(nearest.x - x, nearest.y - y);
                return d1 < d2 ? w : nearest;
              }, null);
            
            if (nearestWorker) sendWorkersToConstruction(newBuilding, [nearestWorker]);
          }
          S.buildMode = null;
          return;
        }
        S.dragging = true;
        S.dragStart = {x: e.clientX, y: e.clientY};
      }
    });

    canvas.addEventListener('mouseup', e => {
      if(e.button === 0) {
        S.dragging = false;
        commitSelection();
      }
    });

    canvas.addEventListener('contextmenu', e => {
      e.preventDefault();
      const {wx, wy} = screenToIsoWorld(e.clientX, e.clientY);
      
      let clicked = null;
      const checkDistance = (items, threshold) => {
        for(const item of items) {
          const s = isoToScreen(item.x, item.y);
          if(Math.hypot(e.clientX - s.x, e.clientY - s.y) < threshold) return item;
        }
        return null;
      };
      
      // Önce binaları kontrol et
      const buildings = S.entities.filter(e => e.kind === 'town' || e.kind === 'house1' || 
        e.kind === 'house2' || e.kind === 'lumberhouse' || e.kind === 'hunterhouse' || e.kind === 'stonehouse');
      clicked = checkDistance(buildings, 40);
      
      // Eğer bina bulunamazsa diğer nesneleri kontrol et
      if(!clicked) clicked = checkDistance(S.trees.filter(t => t.wood > 0), 40);
      if(!clicked) clicked = checkDistance(S.stones.filter(s => s.stone > 0), 40);
      if(!clicked) clicked = checkDistance(S.deer, 40);
      
      const selectedWorkers = [...S.selection].map(id => S.entities.find(e => e.id === id && e.kind === 'worker')).filter(Boolean);
      
      if(clicked && selectedWorkers.length > 0) {
        // Doğru nesne türü tespiti
        let objectType = 'bilinmeyen';
        if(clicked.wood !== undefined) objectType = 'ağaç';
        else if(clicked.stone !== undefined) objectType = 'taş';
        else if(clicked.herdCenterX !== undefined) objectType = 'geyik';
        else if(clicked.kind) objectType = 'bina (' + clicked.kind + ')';
        
        console.log("Tıklanan nesne türü:", objectType);
        
        // Önce en spesifik kontrolleri yap
        if(clicked.wood !== undefined) {
          // Ağaç
          sendWorkersToTree(clicked, selectedWorkers);
        } else if(clicked.stone !== undefined) {
          // Taş
          sendWorkersToStone(clicked, selectedWorkers);
        } else if(clicked.herdCenterX !== undefined) {
          // Geyik - canlı veya ölü kontrolü
          if(clicked.isDead && clicked.meat > 0) {
            sendWorkersToDeadDeer(clicked, selectedWorkers);
          } else if(!clicked.isDead) {
            sendWorkersToDeer(clicked, selectedWorkers);
          }
        } else if(clicked.kind) {
          // Bina - önce inşaat halinde mi kontrol et
          if(clicked.isUnderConstruction) {
            sendWorkersToConstruction(clicked, selectedWorkers);
          } else {
            // Tamamlanmış bina
            sendWorkersToBuilding(clicked, selectedWorkers);
          }
        }
      } else {
        // Hiçbir nesneye tıklanmamışsa, boş yere hareket ettir
        const playerWorkers = selectedWorkers.filter(w => !w.owner);
        if(playerWorkers.length > 0) rightClickMove(playerWorkers);
      }
    });

    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const mx = e.clientX, my = e.clientY;
      const worldBefore = screenToIsoWorld(mx, my);
      
      const zoomFactor = 1.1, minZoom = 0.5, maxZoom = 1.5;
      let newZoom = S.cam.z * (e.deltaY < 0 ? zoomFactor : 1/zoomFactor);
      newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
      if (newZoom === S.cam.z) return;
      
      S.cam.z = newZoom;
      const worldAfter = screenToIsoWorld(mx, my);
      const screenDelta = isoToScreen(worldAfter.wx - worldBefore.wx, worldAfter.wy - worldBefore.wy);
      S.cam.x -= screenDelta.x - (canvas.width/2 - S.cam.x);
      S.cam.y -= screenDelta.y - (canvas.height/2 - S.cam.y);
    });

    document.getElementById('buildBtn').onclick = () => {
      const buildMenu = document.getElementById('buildMenu');
      buildMenu.style.display = buildMenu.style.display === 'none' ? 'block' : 'none';
    };

    document.getElementById('buildHouseBtn').onclick = () => {
      S.buildMode = randomInt(1, 2) === 1 ? 'house1' : 'house2';
    };
    document.getElementById('buildLumberhouseBtn').onclick = () => { S.buildMode = 'lumberhouse'; };
    document.getElementById('buildHunterhouseBtn').onclick = () => { S.buildMode = 'hunterhouse'; };
    document.getElementById('buildStonehouseBtn').onclick = () => { S.buildMode = 'stonehouse'; };

    // Devriye butonuna tıklama olayı
    document.getElementById('patrolBtn').onclick = () => {
        const selectedWorkers = [...S.selection]
            .map(id => S.entities.find(e => e.id === id && e.kind === 'worker'))
            .filter(Boolean);
        
        if (selectedWorkers.length > 0) {
            startPatrol(selectedWorkers);
            console.log(`${selectedWorkers.length} işçi devriyeye başladı!`);
        }
    };

    function simulateLoading() {
      let step = 0;
      const interval = setInterval(() => {
        step++;
        const progress = (step / 10) * 100;
        progressFill.style.width = progress + '%';
        loadingPercentage.textContent = '%' + Math.round(progress);
        
        if (step >= 10) {
          clearInterval(interval);
          setTimeout(() => {
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
              loadingScreen.style.display = 'none';
              startGameMusic();
              centerCameraOnTown();
            }, 500);
          }, 500);
        }
      }, 300);
    }

    window.addEventListener('load', () => {
      simulateLoading();
      setTimeout(() => {
        setupMenu();
        setupSecondTownPanel();
        updateSecondTownPanel(); // İlk yüklemede paneli güncelle
        
        const buttons = [
          { id: 'buildHouseBtn', type: 'house1', name: 'Ev' },
          { id: 'buildLumberhouseBtn', type: 'lumberhouse', name: 'Oduncu Evi' },
          { id: 'buildHunterhouseBtn', type: 'hunterhouse', name: 'Avcı Evi' },
          { id: 'buildStonehouseBtn', type: 'stonehouse', name: 'Taş Ocağı' }
        ];

        buttons.forEach(btn => {
          const element = document.getElementById(btn.id);
          if (!element) return;

          element.addEventListener('mouseenter', e => {
            const cost = buildingCosts[btn.type];
            const tooltip = document.getElementById('tooltip');
            let html = `<div class="tooltip-title">${btn.name}</div><div class="tooltip-cost">`;
            
            if (cost.wood) html += `<div class="tooltip-resource"><img src="assets/icons/odun_icon.png"><span>${cost.wood} Odun</span></div>`;
            if (cost.stone) html += `<div class="tooltip-resource"><img src="assets/icons/tas_icon.png"><span>${cost.stone} Taş</span></div>`;
            if (cost.food) html += `<div class="tooltip-resource"><img src="assets/icons/et_icon.png"><span>${cost.food} Yiyecek</span></div>`;
            
            html += '</div>';
            tooltip.innerHTML = html;
            tooltip.style.display = 'block';
            
            const x = Math.min(e.clientX + 10, window.innerWidth - tooltip.offsetWidth - 10);
            const y = Math.min(e.clientY + 10, window.innerHeight - tooltip.offsetHeight - 10);
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
          });

          element.addEventListener('mousemove', e => {
            const tooltip = document.getElementById('tooltip');
            const x = Math.min(e.clientX + 10, window.innerWidth - tooltip.offsetWidth - 10);
            const y = Math.min(e.clientY + 10, window.innerHeight - tooltip.offsetHeight - 10);
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
          });

          element.addEventListener('mouseleave', () => {
            document.getElementById('tooltip').style.display = 'none';
          });
        });
      }, 2000);
    });

    updateTopBar();
    updateSecondTownPanel();

    function draw(timestamp) {
      if(timestamp === undefined) timestamp = performance.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if(!S.lastConstructionUpdate) S.lastConstructionUpdate = timestamp;
      if(timestamp - S.lastConstructionUpdate > 1000) {
        updateConstruction(timestamp);
        S.lastConstructionUpdate = timestamp;
      }
      
      updateResourceCollection(timestamp);
      updateDeerBehavior(timestamp);
      updateFogOfWar();

      // İşçilerin devriye davranışını güncelle
        S.entities.forEach(worker => {
            if (worker.kind === 'worker' && worker.isPatrolling) {
                updatePatrolBehavior(worker);
            }
        });
    
      
      if (S.lastSelectedBuilding) {
        const building = S.entities.find(e => e.id === S.lastSelectedBuilding);
        if (building?.isUnderConstruction) {
          document.getElementById('constructionPercent').textContent = Math.round(building.constructionProgress);
          document.getElementById('constructionBar').style.width = building.constructionProgress + '%';
        }
      }
      
      if (!secondTownWorkersCreated) createSecondTownWorkers();
      else if (Date.now() % 5000 < 50) assignSecondTownTasks();
      
      if (!lastResourceLogTime) lastResourceLogTime = timestamp;
      if (timestamp - lastResourceLogTime > 30000) {
        console.log(`=== KAYNAKLAR (${new Date().toLocaleTimeString()}) ===`);
        console.log(`Ana Oyuncu - Yiyecek: ${S.res.food}, Odun: ${S.res.wood}, Taş: ${S.res.stone}, Altın: ${S.res.gold}`);
        console.log(`2. Ev - Yiyecek: ${S.secondTownResources.food}, Odun: ${S.secondTownResources.wood}, Taş: ${S.secondTownResources.stone}, Altın: ${S.secondTownResources.gold}`);
        console.log(`2. Ev İşçi Sayısı: ${S.entities.filter(e => e.kind === 'worker' && e.owner === 'secondTown').length}`);
        console.log(`Ana Oyuncu İşçi Sayısı: ${S.entities.filter(e => e.kind === 'worker' && !e.owner).length}`);
        lastResourceLogTime = timestamp;
      }
      
      if (S.selection.size === 1) {
        const selectedEntity = S.entities.find(e => e.id === [...S.selection][0]);
        if (selectedEntity?.kind === 'worker') {
          document.getElementById('workerWood').textContent = selectedEntity.carryingWood || 0;
          document.getElementById('workerStone').textContent = selectedEntity.carryingStone || 0;
          document.getElementById('workerMeat').textContent = selectedEntity.carryingMeat || 0;
        }
      }

      updateEdgeScroll();
      
      const camSpeed = 10;
      if(S.keys['w'] || S.keys['arrowup']) S.cam.y -= camSpeed;
      if(S.keys['s'] || S.keys['arrowdown']) S.cam.y += camSpeed;
      if(S.keys['a'] || S.keys['arrowleft']) S.cam.x -= camSpeed;
      if(S.keys['d'] || S.keys['arrowright']) S.cam.x += camSpeed;

      const mapWidth = (MAP_W + MAP_H) * (TW/2) * S.cam.z;
      const mapHeight = (MAP_W + MAP_H) * (TH/2) * S.cam.z;
      S.cam.x = Math.max(canvas.width/2 - mapWidth/2, Math.min(S.cam.x, canvas.width/2 + mapWidth/2 - canvas.width));
      S.cam.y = Math.max(canvas.height/2 - mapHeight/2, Math.min(S.cam.y, canvas.height/2 + mapHeight/2 - canvas.height + 2000));

      S.entities.forEach(e => {
        if(e.kind === 'worker') {
          if(!e.lastTime) e.lastTime = timestamp;
          const dx = e.tx - e.x, dy = e.ty - e.y, dist = Math.hypot(dx, dy);
          if(dist > 0.01) {
            const deltaTime = (timestamp - e.lastTime) / 1000;
            const moveAmount = MOVE_SPEED * deltaTime;
            e.x = Math.max(0.3, Math.min(MAP_W - 1.3, e.x + (dx / dist) * moveAmount));
            e.y = Math.max(0.3, Math.min(MAP_H - 1.3, e.y + (dy / dist) * moveAmount));
            if(Math.hypot(e.x - e.tx, e.y - e.ty) < 0.05) { e.x = e.tx; e.y = e.ty; }
          } else { e.x = e.tx; e.y = e.ty; }
          e.lastTime = timestamp;
        }
      });

      for(let y = 0; y < MAP_H; y++) {
        for(let x = 0; x < MAP_W; x++) {
          const {x: sx, y: sy} = isoToScreen(x + 0.5, y + 0.5);
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx + TW/2 * S.cam.z, sy + TH/2 * S.cam.z);
          ctx.lineTo(sx, sy + TH * S.cam.z);
          ctx.lineTo(sx - TW/2 * S.cam.z, sy + TH/2 * S.cam.z);
          ctx.closePath();
          ctx.fillStyle = '#2d7a32';
          ctx.fill();
          ctx.strokeStyle = 'rgba(255,255,255,.06)';
          ctx.stroke();
        }
      }

      const allObjects = [];
      S.trees.forEach(tree => allObjects.push({ type: 'tree', data: tree, y: tree.y }));
      S.stones.forEach(stone => allObjects.push({ type: 'stone', data: stone, y: stone.y }));
      S.deer.forEach(deer => allObjects.push({ type: 'deer', data: deer, y: deer.y }));
      S.entities.forEach(entity => {
        if(entity.kind !== 'worker') allObjects.push({ type: 'building', data: entity, y: entity.y });
      });
      S.entities.forEach(entity => {
        if(entity.kind === 'worker') allObjects.push({ type: 'worker', data: entity, y: entity.y });
      });
      
      allObjects.sort((a, b) => a.y - b.y);
      
      allObjects.forEach(obj => {
        const {x: sx, y: sy} = isoToScreen(obj.data.x, obj.data.y);
        
        if(obj.type === 'tree') {
          const tree = obj.data;
          const treeImg = treeImages['type' + tree.type];
          let shakeX = 0, shakeY = 0;
          if (S.shakingTrees.has(tree)) {
            shakeX = (Math.random() - 0.5) * 3 * S.cam.z;
            shakeY = (Math.random() - 0.5) * 1.5 * S.cam.z;
          }
          
          if(treeImg?.complete) {
            ctx.drawImage(treeImg, sx - 24 * S.cam.z + shakeX, sy - 48 * S.cam.z + shakeY, 48 * S.cam.z, 48 * S.cam.z);
          }

          if(S.selection.has('tree_' + S.trees.indexOf(tree))) {
            ctx.strokeStyle = 'cyan';
            ctx.beginPath();
            ctx.arc(sx + shakeX, sy - 24 * S.cam.z + shakeY, 12 * S.cam.z, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else if(obj.type === 'stone') {
          const stone = obj.data;
          const stoneImg = stoneImages['type' + stone.type];
          
          if(stoneImg?.complete) {
            ctx.drawImage(stoneImg, sx - 24 * S.cam.z, sy - 48 * S.cam.z, 48 * S.cam.z, 48 * S.cam.z);
          }

          if(S.selection.has('stone_' + S.stones.indexOf(stone))) {
            ctx.strokeStyle = 'cyan';
            ctx.beginPath();
            ctx.arc(sx, sy - 24 * S.cam.z, 12 * S.cam.z, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else if(obj.type === 'deer') {
          const deer = obj.data;
          const deerImg = deer.isDead ? deerImages.dead : deerImages.alive;
          
          if(deerImg?.complete) {
            ctx.save();
            if (!deer.isDead && deer.direction === -1) {
              ctx.translate(sx, sy);
              ctx.scale(-1, 1);
              ctx.translate(-sx, -sy);
            }
            ctx.drawImage(deerImg, sx - 24 * S.cam.z, sy - 48 * S.cam.z, 48 * S.cam.z, 48 * S.cam.z);
            ctx.restore();
          }

          const barWidth = 40 * S.cam.z, barHeight = 4 * S.cam.z;
          if(deer.isDead) {
            const meatPercent = (deer.meat / deer.maxMeat) * 100;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(sx - barWidth/2, sy - 50 * S.cam.z, barWidth, barHeight);
            ctx.fillStyle = '#FF9800';
            ctx.fillRect(sx - barWidth/2, sy - 50 * S.cam.z, barWidth * (meatPercent/100), barHeight);
          } else {
            const healthPercent = (deer.health / deer.maxHealth) * 100;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(sx - barWidth/2, sy - 50 * S.cam.z, barWidth, barHeight);
            ctx.fillStyle = healthPercent > 70 ? '#FF6B6B' : healthPercent > 30 ? '#FF5252' : '#FF0000';
            ctx.fillRect(sx - barWidth/2, sy - 50 * S.cam.z, barWidth * (healthPercent/100), barHeight);
          }

          if(S.selection.has('deer_' + S.deer.indexOf(deer))) {
            ctx.strokeStyle = 'cyan';
            ctx.beginPath();
            ctx.arc(sx, sy - 24 * S.cam.z, 12 * S.cam.z, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else if(obj.type === 'building') {
          const building = obj.data;
          ctx.globalAlpha = building.isUnderConstruction ? 0.5 : 1.0;

          const buildingImg = buildingImages[building.kind];
          if(buildingImg?.complete) {
            ctx.drawImage(buildingImg, sx - 36 * S.cam.z, sy - 72 * S.cam.z, 72 * S.cam.z, 72 * S.cam.z);
          }

          if(building.isUnderConstruction) {
            const barWidth = 40 * S.cam.z, barHeight = 4 * S.cam.z;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(sx - barWidth/2, sy - 80 * S.cam.z, barWidth, barHeight);
            ctx.fillStyle = '#FF9800';
            ctx.fillRect(sx - barWidth/2, sy - 80 * S.cam.z, barWidth * (building.constructionProgress/100), barHeight);
          }

          // DEĞİŞİKLİK: 2. EV İÇİN SEÇİM HALKASI GÖSTERME
          if(S.selection.has(building.id) && building.kind !== 'town2') {
            ctx.strokeStyle = 'cyan';
            ctx.beginPath();
            ctx.arc(sx, sy - 36 * S.cam.z, 15 * S.cam.z, 0, Math.PI * 2);
            ctx.stroke();
          }
          
          ctx.globalAlpha = 1.0;
        } else if(obj.type === 'worker') {
          const worker = obj.data;
          
          // İŞÇİ GÖRSELLERİ İLE DEĞİŞTİRİLDİ
          const workerImg = workerImages[worker.workerType];
          if(workerImg?.complete) {

            // Yön tespiti - hareket yönüne göre
            let direction = 1; // Varsayılan sağa bakıyor
            if (worker.tx !== undefined && worker.x !== undefined) {
                const dx = worker.tx - worker.x;
                if (dx < -0.1) direction = -1; // Sola gidiyor
                else if (dx > 0.1) direction = 1; // Sağa gidiyor
                // Çok küçük hareketlerde yönü değiştirme
            }
            // Renk durumuna göre filtre uygula
            ctx.save();

            // Yönü ayarla (mirrorlama)
            if (direction === -1) {
                ctx.translate(sx, sy);
                ctx.scale(-1, 1);
                ctx.translate(-sx, -sy);
            }
            
            if (worker.owner === 'secondTown') {
              // 2. Ev işçileri kırmızı ton
              ctx.filter = 'hue-rotate(300deg) saturate(1.5)';
            } else if(worker.isConstructing) {
              ctx.filter = 'hue-rotate(30deg)'; // turuncu
            } else if(worker.isChopping) {
              ctx.filter = 'hue-rotate(180deg) saturate(0.7)'; // kahverengi
            } else if(worker.isMining) {
              ctx.filter = 'grayscale(0.8)'; // gri
            } else if(worker.isHunting) {
              ctx.filter = 'hue-rotate(300deg) saturate(1.2)'; // koyu kırmızı
            } else if(worker.isCollectingMeat) {
              ctx.filter = 'hue-rotate(30deg) saturate(1.3)'; // turuncu
            } else if(worker.isDeliveringToBuilding) {
              ctx.filter = 'hue-rotate(270deg)'; // mor
            } else if(worker.isDelivering) {
              ctx.filter = 'hue-rotate(120deg) saturate(0.8)'; // koyu yeşil
            }
            
            const size = 20 * S.cam.z;
            ctx.drawImage(workerImg, sx - size/2, sy - size - 4, size, size);
            ctx.restore();
          }

          // Seçim çemberi
          if(S.selection.has(worker.id)) {
            ctx.strokeStyle = 'cyan';
            ctx.beginPath();
            ctx.arc(sx, sy + 2 * S.cam.z, 12 * S.cam.z, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      });

      if(S.dragging) {
        const minX = Math.min(S.dragStart.x, S.mouse.x);
        const minY = Math.min(S.dragStart.y, S.mouse.y);
        const width = Math.abs(S.dragStart.x - S.mouse.x);
        const height = Math.abs(S.dragStart.y - S.mouse.y);
        ctx.strokeStyle = 'lime';
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(minX, minY, width, height);
        ctx.setLineDash([]);
      }

      if(S.buildMode) {
        const gx = Math.floor(S.mouse.wx), gy = Math.floor(S.mouse.wy);
        const {x: sx, y: sy} = isoToScreen(gx, gy);
        
        let canBuild = true;
        for(const entity of S.entities) {
          if((entity.kind === 'town' || entity.kind === 'house1' || entity.kind === 'house2' || 
             entity.kind === 'lumberhouse' || entity.kind === 'hunterhouse' || entity.kind === 'stonehouse') &&
             Math.floor(entity.x) === gx && Math.floor(entity.y) === gy) {
            canBuild = false; break;
          }
        }
        
        if(canBuild) {
          for(const tree of S.trees) {
            if(Math.floor(tree.x) === gx && Math.floor(tree.y) === gy) { canBuild = false; break; }
          }
        }
        
        if(canBuild) {
          for(const stone of S.stones) {
            if(Math.floor(stone.x) === gx && Math.floor(stone.y) === gy) { canBuild = false; break; }
          }
        }
        
        if(canBuild) {
          for(const deer of S.deer) {
            if(Math.floor(deer.x) === gx && Math.floor(deer.y) === gy) { canBuild = false; break; }
          }
        }
        
        ctx.globalAlpha = 0.5;
        const buildImg = buildingImages[S.buildMode];

        if(!canBuild) {
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.fillRect(sx - 36 * S.cam.z, sy - 72 * S.cam.z, 72 * S.cam.z, 72 * S.cam.z);
          ctx.globalAlpha = 0.5;
        }
        
        if(buildImg?.complete) {
          ctx.drawImage(buildImg, sx - 36 * S.cam.z, sy - 72 * S.cam.z, 72 * S.cam.z, 72 * S.cam.z);
        }
        
        ctx.globalAlpha = 1.0;
      }

      for(let y = 0; y < MAP_H; y++) {
        for(let x = 0; x < MAP_W; x++) {
          if(S.fogOfWar[y][x]) {
            const {x: sx, y: sy} = isoToScreen(x + 0.5, y + 0.5);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + TW/2 * S.cam.z, sy + TH/2 * S.cam.z);
            ctx.lineTo(sx, sy + TH * S.cam.z);
            ctx.lineTo(sx - TW/2 * S.cam.z, sy + TH/2 * S.cam.z);
            ctx.closePath();
            ctx.fillStyle = S.explored[y][x] ? 'rgba(0, 0, 0, 0.7)' : 'rgba(0, 0, 0, 1)';
            ctx.fill();
          }
        }
      }

      requestAnimationFrame(draw);
    }

    requestAnimationFrame(draw);
  </script>
</body>
</html>