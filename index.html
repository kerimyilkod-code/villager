<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RTS Step 6 â€“ Deer Hunting</title>
  <style>
    :root{ --bg:#0e1020; --panel:#161a33; --panel-2:#1a1f3d; --ink:#e9ecff; }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial; overflow:hidden}
    #topbar{position:fixed; top:8px; left:8px; right:8px; display:flex; align-items:center; gap:10px; z-index:10; padding:8px; border-radius:14px; background:linear-gradient(180deg,var(--panel),#11152a); box-shadow:0 10px 30px rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.06);}
    .res{background:var(--panel-2); padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.04); min-width:84px; text-align:center}
    .res b{display:block; font-size:12px; opacity:.85}
    .res span{font-weight:700}
    #population{background:var(--panel-2); padding:6px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.04); min-width:120px; text-align:center}
    #rightpanel{position:fixed; right:8px; top:64px; width:280px; bottom:8px; display:flex; flex-direction:column; gap:10px; z-index:9;
      pointer-events: none;
    }
    .card{background:linear-gradient(180deg,var(--panel),#0f1330); padding:12px; border-radius:16px; border:1px solid rgba(255,255,255,.06);
      pointer-events: auto;
    }
    .title{font-weight:700; margin-bottom:8px}
    .grid{display:grid; grid-template-columns:repeat(3,1fr); gap:8px}
    .btn{cursor:pointer; padding:8px; border-radius:10px; text-align:center; background:#222853; border:1px solid rgba(255,255,255,.06); color:var(--ink); transition: all 0.2s ease;}
    .btn:hover{background:#2a3068; transform: translateY(-1px);}
    #game{position:absolute; inset:0;}
    #hint{position:fixed; left:8px; bottom:8px; font-size:12px; opacity:.9; background:rgba(0,0,0,.25); padding:6px 8px; border-radius:8px}
    
    .health-bar-container, .wood-bar-container, .stone-bar-container, .deer-health-bar-container, .deer-meat-bar-container {
      margin-top: 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
      padding: 2px;
    }
    .health-bar, .wood-bar, .stone-bar, .deer-health-bar, .deer-meat-bar {
      height: 12px;
      border-radius: 2px;
      transition: width 0.3s ease;
    }
    .health-bar { background: linear-gradient(90deg, #4CAF50, #8BC34A); }
    .wood-bar { background: linear-gradient(90deg, #8B4513, #A0522D); }
    .stone-bar { background: linear-gradient(90deg, #666666, #888888); }
    .deer-health-bar { background: linear-gradient(90deg, #FF6B6B, #FF8E8E); }
    .deer-meat-bar { background: linear-gradient(90deg, #FF9800, #FFC107); }
    .health-text, .wood-text, .stone-text, .deer-health-text, .deer-meat-text {
      font-size: 12px;
      margin-top: 4px;
      text-align: center;
      opacity: 0.8;
    }
    
    .construction-bar-container {
      margin-top: 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
      padding: 2px;
    }
    .construction-bar {
      height: 8px;
      background: linear-gradient(90deg, #FF9800, #FFC107);
      border-radius: 2px;
      transition: width 0.3s ease;
    }
    .construction-text {
      font-size: 11px;
      margin-top: 2px;
      text-align: center;
      opacity: 0.8;
    }
    
    /* YENÄ°: Resource icon styles */
    .resource-icon {
      width: 16px;
      height: 16px;
      vertical-align: middle;
      margin-right: 4px;
    }
    
    .worker-resource {
      margin-top: 6px;
      font-size: 11px;
      text-align: center;
      opacity: 0.8;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    /* YENÄ°: Loading Screen Styles */
    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0e1020, #1a1f3d);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.5s ease;
    }

    #loadingScreen.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    .game-title {
      font-family: 'Segoe Print', 'Bradley Hand', 'Brush Script MT', cursive;
      font-size: 5rem;
      font-weight: bold;
      background: linear-gradient(45deg, #FFD700, #FFA500, #FF8C00);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
      margin-bottom: 2rem;
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from {
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      }
      to {
        text-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6);
      }
    }

    .loading-container {
      width: 300px;
      background: rgba(22, 26, 51, 0.8);
      border-radius: 15px;
      padding: 2rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .loading-text {
      text-align: center;
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: #e9ecff;
    }

    .progress-bar {
      width: 100%;
      height: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A, #FFD700);
      border-radius: 10px;
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% {
        left: -100%;
      }
      100% {
        left: 100%;
      }
    }

    .loading-percentage {
      text-align: center;
      font-size: 0.9rem;
      margin-top: 0.5rem;
      color: #e9ecff;
      opacity: 0.8;
    }

    .game-hint {
      margin-top: 2rem;
      text-align: center;
      font-size: 0.9rem;
      color: #e9ecff;
      opacity: 0.7;
      font-style: italic;
    }

    /* YENÄ°: Selection header styles */
    .selection-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .selection-icon {
      width: 24px;
      height: 24px;
    }
    .btn-icon {
      width: 20px;
      height: 20px;
      margin-bottom: 4px;
    }

    /* YENÄ°: MenÃ¼ butonu ve menÃ¼ stilleri */
    #menuBtn {
      background: var(--panel-2);
      padding: 8px 16px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.04);
      color: var(--ink);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      transition: all 0.2s ease;
    }

    #menuBtn:hover {
      background: #2a3068;
      transform: translateY(-1px);
    }

    /* MenÃ¼ overlay */
    #menuOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }

    .menu-container {
      background: linear-gradient(180deg, var(--panel), #0f1330);
      border-radius: 20px;
      padding: 2rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      width: 300px;
      max-width: 90vw;
    }

    .menu-title {
      text-align: center;
      font-size: 1.5rem;
      margin-bottom: 2rem;
      font-weight: bold;
      background: linear-gradient(45deg, #FFD700, #FFA500);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .menu-btn {
      padding: 15px 20px;
      background: linear-gradient(180deg, #222853, #1a1f3d);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      color: var(--ink);
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: flex-start;
    }

    .menu-btn:hover {
      background: linear-gradient(180deg, #2a3068, #222853);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .menu-btn i {
      font-size: 1.2rem;
      width: 24px;
      text-align: center;
    }

    /* Ayarlar menÃ¼sÃ¼ */
    #settingsMenu {
      display: none;
    }

    .settings-section {
      margin-bottom: 1.5rem;
    }

    .settings-title {
      font-size: 1rem;
      margin-bottom: 1rem;
      color: #e9ecff;
      opacity: 0.9;
    }

    .volume-control {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 1rem;
    }

    .volume-slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
      outline: none;
    }

    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
    }

    .volume-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
      border: none;
    }

    .back-btn {
      background: rgba(255,255,255,0.1);
      border: none;
      color: var(--ink);
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 1rem;
      transition: all 0.2s ease;
    }

    .back-btn:hover {
      background: rgba(255,255,255,0.2);
    }

    /* YENÄ°: Tooltip stilleri */
    #tooltip {
      position: fixed;
      display: none;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.1);
      border-radius: 8px;
      padding: 8px;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
    }

    .tooltip-content {
      font-size: 12px;
      color: var(--ink);
    }

    .tooltip-resource {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 4px 0;
    }

    .tooltip-resource img {
      width: 16px;
      height: 16px;
    }

    .tooltip-title {
      font-weight: bold;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(255,255,255,.1);
      padding-bottom: 4px;
    }

    .tooltip-cost {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
  </style>
  <!-- Windows el yazÄ±sÄ± fontlarÄ± iÃ§in -->
  <link href="https://fonts.googleapis.com/css2?family=Segoe+Print&display=swap" rel="stylesheet">
  <!-- Ä°konlar iÃ§in Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

  <!-- MÃ¼zik dosyalarÄ± -->
  <audio id="themeMusic1" loop>
    <source src="assets/sounds/main_theme1.mp3" type="audio/mpeg">
  </audio>
  <audio id="themeMusic2" loop>
    <source src="assets/sounds/main_theme2.mp3" type="audio/mpeg">
  </audio>

  <!-- YENÄ°: Ses efektleri -->
  <audio id="buildSound" preload="auto">
    <source src="assets/sounds/build.mp3" type="audio/mpeg">
  </audio>
  <audio id="houseSound" preload="auto">
    <source src="assets/sounds/house.mp3" type="audio/mpeg">
  </audio>
  <audio id="stonemasonSound" preload="auto">
    <source src="assets/sounds/stonemason.mp3" type="audio/mpeg">
  </audio>
  <audio id="lumberSound" preload="auto">
    <source src="assets/sounds/lumber.mp3" type="audio/mpeg">
  </audio>
  <audio id="hunterSound" preload="auto">
    <source src="assets/sounds/hunter.mp3" type="audio/mpeg">
  </audio>
</head>
<body>
  <!-- YENÄ°: Loading Screen -->
  <div id="loadingScreen">
    <div class="game-title">Villager</div>
    <div class="loading-container">
      <div class="loading-text">Oyun YÃ¼kleniyor...</div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="loading-percentage" id="loadingPercentage">%0</div>
    </div>
    <div class="game-hint">KaynaklarÄ± topla, binalar inÅŸa et, kÃ¶yÃ¼nÃ¼ bÃ¼yÃ¼t!</div>
  </div>

  <!-- YENÄ°: MenÃ¼ Overlay -->
  <div id="menuOverlay">
    <div class="menu-container" id="mainMenu">
      <div class="menu-title">OYUN MENÃœSÃœ</div>
      <div class="menu-buttons">
        <button class="menu-btn" id="resumeBtn">
          <i class="fas fa-play"></i>
          Devam Et
        </button>
        <button class="menu-btn" id="newGameBtn">
          <i class="fas fa-plus-circle"></i>
          Yeni Oyun
        </button>
        <button class="menu-btn" id="saveBtn">
          <i class="fas fa-save"></i>
          Oyunu Kaydet
        </button>
        <button class="menu-btn" id="loadBtn">
          <i class="fas fa-folder-open"></i>
          Oyunu YÃ¼kle
        </button>
        <button class="menu-btn" id="settingsBtn">
          <i class="fas fa-cog"></i>
          Ayarlar
        </button>
      </div>
    </div>

    <!-- Ayarlar MenÃ¼sÃ¼ -->
    <div class="menu-container" id="settingsMenu">
      <div class="menu-title">AYARLAR</div>
      <div class="settings-section">
        <div class="settings-title">Ses AyarlarÄ±</div>
        <div class="volume-control">
          <i class="fas fa-volume-up"></i>
          <input type="range" class="volume-slider" id="menuVolumeSlider" min="0" max="100" value="50">
          <span id="menuVolumePercent" style="min-width: 40px;">50%</span>
        </div>
        <button class="menu-btn" id="muteToggleBtn">
          <i class="fas fa-volume-mute"></i>
          Sesi AÃ§/Kapat
        </button>
      </div>
      <button class="back-btn" id="backToMainBtn">
        <i class="fas fa-arrow-left"></i>
        Ana MenÃ¼ye DÃ¶n
      </button>
    </div>
  </div>

  <!-- YENÄ°: Tooltip container -->
  <div id="tooltip"></div>

  <canvas id="game"></canvas>
  <div id="topbar">
    <div class="res"><img src="assets/icons/et_icon.png" class="resource-icon" alt="Yiyecek"><b>Yiyecek</b> <span id="food">100</span></div>
    <div class="res"><img src="assets/icons/odun_icon.png" class="resource-icon" alt="Odun"><b>Odun</b> <span id="wood">200</span></div>
    <div class="res"><img src="assets/icons/tas_icon.png" class="resource-icon" alt="TaÅŸ"><b>TaÅŸ</b> <span id="stone">100</span></div>
    <div class="res"><img src="assets/icons/altin_icon.png" class="resource-icon" alt="AltÄ±n"><b>AltÄ±n</b> <span id="gold">0</span></div>
    <div id="population">ðŸ‘¥ <span id="popCur">0</span> / <span id="popMax">0</span></div>
    
    <!-- YENÄ°: MenÃ¼ Butonu -->
    <div id="menuBtn">
      <i class="fas fa-bars"></i>
      MenÃ¼
    </div>
    
    <div style="margin-left:auto; opacity:.8">RTS Step 6 â€“ Deer Hunting</div>
  </div>
  <aside id="rightpanel">
    <div class="card" id="selectionCard">
      <div class="title">SeÃ§ili Nesne</div>
      <div id="selectionInfo">HiÃ§bir ÅŸey seÃ§ili deÄŸil.</div>
      <div id="healthContainer" style="display:none;">
        <div class="health-text">SaÄŸlÄ±k: <span id="healthPercent">100</span>%</div>
        <div class="health-bar-container">
          <div class="health-bar" id="healthBar" style="width:100%"></div>
        </div>
      </div>
      <div id="woodContainer" style="display:none;">
        <div class="wood-text">Odun: <span id="woodAmount">0</span>/200</div>
        <div class="wood-bar-container">
          <div class="wood-bar" id="woodBar" style="width:0%"></div>
        </div>
      </div>
      <div id="stoneContainer" style="display:none;">
        <div class="stone-text">TaÅŸ: <span id="stoneAmount">0</span>/200</div>
        <div class="stone-bar-container">
          <div class="stone-bar" id="stoneBar" style="width:0%"></div>
        </div>
      </div>
      <div id="deerHealthContainer" style="display:none;">
        <div class="deer-health-text">Can: <span id="deerHealthAmount">0</span>/200</div>
        <div class="deer-health-bar-container">
          <div class="deer-health-bar" id="deerHealthBar" style="width:0%"></div>
        </div>
      </div>
      <div id="deerMeatContainer" style="display:none;">
        <div class="deer-meat-text">Et: <span id="deerMeatAmount">0</span>/200</div>
        <div class="deer-meat-bar-container">
          <div class="deer-meat-bar" id="deerMeatBar" style="width:0%"></div>
        </div>
      </div>
      <div id="constructionContainer" style="display:none;">
        <div class="construction-text">Ä°nÅŸaat: <span id="constructionPercent">0</span>%</div>
        <div class="construction-bar-container">
          <div class="construction-bar" id="constructionBar" style="width:0%"></div>
        </div>
      </div>
      
      <div id="workerResourceContainer" style="display:none;">
        <div class="worker-resource">
          <img src="assets/icons/odun_icon.png" class="resource-icon" alt="Odun">
          TaÅŸÄ±dÄ±ÄŸÄ± Odun: <span id="workerWood">0</span>
        </div>
        <div class="worker-resource">
          <img src="assets/icons/tas_icon.png" class="resource-icon" alt="TaÅŸ">
          TaÅŸÄ±dÄ±ÄŸÄ± TaÅŸ: <span id="workerStone">0</span>
        </div>
        <div class="worker-resource">
          <img src="assets/icons/et_icon.png" class="resource-icon" alt="Et">
          TaÅŸÄ±dÄ±ÄŸÄ± Et: <span id="workerMeat">0</span>
        </div>
      </div>
      
      <div id="spawnBtnContainer" style="margin-top:8px;"></div>
    </div>
    <div class="card" id="commandCard" style="display:none;">
      <div class="title">Komutlar</div>
      <div class="grid">
        <div class="btn" id="buildBtn">
          <img src="assets/icons/insa_icon.png" class="btn-icon" alt="Ä°nÅŸa">
          <div class="btn-text">Ä°nÅŸa</div>
        </div>
        <div class="btn" id="gatherBtn">Topla</div>
        <div class="btn" id="patrolBtn">Devriye</div>
      </div>

      <div id="buildMenu" style="margin-top:8px; display:none;">
        <div class="grid">
          <div class="btn" id="buildHouseBtn">
            <img src="assets/icons/house_icon.png" class="btn-icon" alt="Ev">
            <div class="btn-text">Ev</div>
          </div>
          <div class="btn" id="buildLumberhouseBtn">
            <img src="assets/icons/oduncu_icon.png" class="btn-icon" alt="Oduncu Evi">
            <div class="btn-text">Oduncu Evi</div>
          </div>
          <div class="btn" id="buildHunterhouseBtn">
            <img src="assets/icons/avci_evi_icon.png" class="btn-icon" alt="AvcÄ± Evi">
            <div class="btn-text">AvcÄ± Evi</div>
          </div>
          <div class="btn" id="buildStonehouseBtn">
            <img src="assets/icons/tas_evi_icon.png" class="btn-icon" alt="TaÅŸ OcaÄŸÄ±">
            <div class="btn-text">TaÅŸ OcaÄŸÄ±</div>
          </div>
        </div>
      </div>

    </div>
  </aside>
  <div id="hint">WASD veya Ok TuÅŸlarÄ±: Kamera â€¢ Scroll: Zoom â€¢ Sol Fare: SeÃ§im â€¢ SaÄŸ Fare: SeÃ§ili birimi hedefe gÃ¶nder â€¢ Delete: SeÃ§ili binayÄ± sil â€¢ ESC: MenÃ¼ â€¢ Mouse Kenar: Harita KaydÄ±rma</div>
  <script>
    // YENÄ°: Loading Screen KontrolÃ¼
    const loadingScreen = document.getElementById('loadingScreen');
    const progressFill = document.getElementById('progressFill');
    const loadingPercentage = document.getElementById('loadingPercentage');

    // YENÄ°: MÃ¼zik deÄŸiÅŸkenleri
    let currentMusic = 1;
    let isMusicPlaying = false;

    // YENÄ°: Ses kontrol deÄŸiÅŸkenleri
    let musicVolume = 0.5; // VarsayÄ±lan ses seviyesi (%50)
    let isMuted = false;

    // YENÄ°: Ses efektleri deÄŸiÅŸkenleri
    let soundEffectsEnabled = true;
    let effectsVolume = 0.7; // Efekt ses seviyesi

    // YENÄ°: MenÃ¼ deÄŸiÅŸkenleri
    const menuOverlay = document.getElementById('menuOverlay');
    const mainMenu = document.getElementById('mainMenu');
    const settingsMenu = document.getElementById('settingsMenu');
    const menuBtn = document.getElementById('menuBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const newGameBtn = document.getElementById('newGameBtn');
    const saveBtn = document.getElementById('saveBtn');
    const loadBtn = document.getElementById('loadBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const backToMainBtn = document.getElementById('backToMainBtn');
    const menuVolumeSlider = document.getElementById('menuVolumeSlider');
    const menuVolumePercent = document.getElementById('menuVolumePercent');
    const muteToggleBtn = document.getElementById('muteToggleBtn');

    // YENÄ°: MenÃ¼ yÃ¶netimi
    function setupMenu() {
        // MenÃ¼ butonu
        menuBtn.addEventListener('click', openMenu);
        
        // MenÃ¼ butonlarÄ±
        resumeBtn.addEventListener('click', closeMenu);
        newGameBtn.addEventListener('click', startNewGame);
        saveBtn.addEventListener('click', saveGame);
        loadBtn.addEventListener('click', loadGame);
        settingsBtn.addEventListener('click', showSettings);
        backToMainBtn.addEventListener('click', showMainMenu);
        
        // Ses kontrolleri
        menuVolumeSlider.addEventListener('input', function() {
            musicVolume = this.value / 100;
            updateVolume();
            menuVolumePercent.textContent = this.value + '%';
        });
        
        muteToggleBtn.addEventListener('click', function() {
            isMuted = !isMuted;
            soundEffectsEnabled = !isMuted;
            updateVolume();
            updateMuteButton();
        });
        
        // ESC tuÅŸu ile menÃ¼ aÃ§/kapa
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (menuOverlay.style.display === 'flex') {
                    closeMenu();
                } else {
                    openMenu();
                }
            }
        });
        
        // MenÃ¼ dÄ±ÅŸÄ±na tÄ±klama ile kapatma
        menuOverlay.addEventListener('click', function(e) {
            if (e.target === menuOverlay) {
                closeMenu();
            }
        });
    }

    function startNewGame() {
        if (confirm('Yeni oyun baÅŸlatmak istediÄŸinize emin misiniz?')) {
            location.reload();
        }
    }

    function openMenu() {
        menuOverlay.style.display = 'flex';
        showMainMenu();
        // Mevcut ses ayarlarÄ±nÄ± menÃ¼ye yansÄ±t
        menuVolumeSlider.value = musicVolume * 100;
        menuVolumePercent.textContent = Math.round(musicVolume * 100) + '%';
        updateMuteButton();
    }

    function closeMenu() {
        menuOverlay.style.display = 'none';
    }

    function showMainMenu() {
        mainMenu.style.display = 'block';
        settingsMenu.style.display = 'none';
    }

    function showSettings() {
        mainMenu.style.display = 'none';
        settingsMenu.style.display = 'block';
    }

    function updateMuteButton() {
        const icon = muteToggleBtn.querySelector('i');
        if (isMuted) {
            icon.className = 'fas fa-volume-mute';
            muteToggleBtn.innerHTML = '<i class="fas fa-volume-mute"></i> Sesi AÃ§';
        } else {
            icon.className = 'fas fa-volume-up';
            muteToggleBtn.innerHTML = '<i class="fas fa-volume-up"></i> Sesi Kapat';
        }
    }

    // YENÄ°: Ses efekti Ã§alma fonksiyonu
    function playSoundEffect(soundId) {
      if (!soundEffectsEnabled) return;
      
      const sound = document.getElementById(soundId);
      if (sound) {
        sound.volume = effectsVolume;
        sound.currentTime = 0; // Sesi baÅŸa sar
        sound.play().catch(error => {
          console.log("Ses efekti Ã§alÄ±namadÄ±:", error);
        });
      }
    }

    // YENÄ°: Ses efektlerini gÃ¼ncelleme fonksiyonu
    function updateSoundEffects() {
      const buildSound = document.getElementById('buildSound');
      const houseSound = document.getElementById('houseSound');
      const stonemasonSound = document.getElementById('stonemasonSound');
      const lumberSound = document.getElementById('lumberSound');
      const hunterSound = document.getElementById('hunterSound');
      
      if (buildSound) buildSound.volume = effectsVolume;
      if (houseSound) houseSound.volume = effectsVolume;
      if (stonemasonSound) stonemasonSound.volume = effectsVolume;
      if (lumberSound) lumberSound.volume = effectsVolume;
      if (hunterSound) hunterSound.volume = effectsVolume;
    }

    function startGameMusic() {
      if (isMusicPlaying) return;
      
      isMusicPlaying = true;
      currentMusic = 1;
      const music1 = document.getElementById('themeMusic1');
      const music2 = document.getElementById('themeMusic2');
      
      // Ses seviyesini ayarla
      music1.volume = isMuted ? 0 : musicVolume;
      music2.volume = isMuted ? 0 : musicVolume;
      
      music1.play().then(() => {
        console.log("Oyun mÃ¼ziÄŸi baÅŸladÄ±: Theme 1");
      }).catch(error => {
        console.log("MÃ¼zik Ã§alma hatasÄ±:", error);
      });
      
      music1.addEventListener('ended', function() {
        currentMusic = 2;
        music2.play().then(() => {
          console.log("Oyun mÃ¼ziÄŸi: Theme 2");
        });
      });
      
      music2.addEventListener('ended', function() {
        currentMusic = 1;
        music1.play().then(() => {
          console.log("Oyun mÃ¼ziÄŸi: Theme 1");
        });
      });
    }

    function stopGameMusic() {
      const music1 = document.getElementById('themeMusic1');
      const music2 = document.getElementById('themeMusic2');
      
      music1.pause();
      music2.pause();
      music1.currentTime = 0;
      music2.currentTime = 0;
      isMusicPlaying = false;
    }

    let loadingProgress = 0;
    const totalLoadSteps = 10;

    function updateProgress(step) {
      loadingProgress = (step / totalLoadSteps) * 100;
      progressFill.style.width = loadingProgress + '%';
      loadingPercentage.textContent = '%' + Math.round(loadingProgress);
      
      if (step >= totalLoadSteps) {
        setTimeout(() => {
          loadingScreen.classList.add('fade-out');
          setTimeout(() => {
            loadingScreen.style.display = 'none';
            startGameMusic();
          }, 500);
        }, 500);
      }
    }

    function simulateLoading() {
      let step = 0;
      const interval = setInterval(() => {
        step++;
        updateProgress(step);
        
        if (step >= totalLoadSteps) {
          clearInterval(interval);
          setTimeout(() => {
            loadingScreen.classList.add('fade-out');
            setTimeout(() => {
              loadingScreen.style.display = 'none';
              startGameMusic();
            }, 500);
          }, 500);
        }
      }, 300);
    }

    // Ses gÃ¼ncelleme fonksiyonu
    function updateVolume() {
        const music1 = document.getElementById('themeMusic1');
        const music2 = document.getElementById('themeMusic2');
        
        if (music1 && music2) {
            if (isMuted) {
                music1.volume = 0;
                music2.volume = 0;
            } else {
                music1.volume = musicVolume;
                music2.volume = musicVolume;
            }
        }
        
        // YENÄ°: Efekt seslerini de gÃ¼ncelle
        updateSoundEffects();
    }

    // YENÄ°: Tooltip sistemi
    const buildingCosts = {
        'house1': { wood: 50 },
        'house2': { wood: 50 },
        'lumberhouse': { wood: 50 },
        'hunterhouse': { wood: 50 },
        'stonehouse': { wood: 75 }
    };

    function setupTooltips() {
        const tooltip = document.getElementById('tooltip');
        const buttons = [
            { id: 'buildHouseBtn', type: 'house1', name: 'Ev' },
            { id: 'buildLumberhouseBtn', type: 'lumberhouse', name: 'Oduncu Evi' },
            { id: 'buildHunterhouseBtn', type: 'hunterhouse', name: 'AvcÄ± Evi' },
            { id: 'buildStonehouseBtn', type: 'stonehouse', name: 'TaÅŸ OcaÄŸÄ±' }
        ];

        buttons.forEach(button => {
            const element = document.getElementById(button.id);
            if (!element) return;

            element.addEventListener('mouseenter', function(e) {
                const cost = buildingCosts[button.type];
                showTooltip(e, button.name, cost);
            });

            element.addEventListener('mousemove', function(e) {
                updateTooltipPosition(e);
            });

            element.addEventListener('mouseleave', function() {
                hideTooltip();
            });
        });
    }

    function showTooltip(event, buildingName, cost) {
        const tooltip = document.getElementById('tooltip');
        
        let html = `<div class="tooltip-title">${buildingName}</div>`;
        html += '<div class="tooltip-cost">';
        
        if (cost.wood) {
            html += `<div class="tooltip-resource">
                        <img src="assets/icons/odun_icon.png" alt="Odun">
                        <span>${cost.wood} Odun</span>
                     </div>`;
        }
        
        if (cost.stone) {
            html += `<div class="tooltip-resource">
                        <img src="assets/icons/tas_icon.png" alt="TaÅŸ">
                        <span>${cost.stone} TaÅŸ</span>
                     </div>`;
        }
        
        if (cost.food) {
            html += `<div class="tooltip-resource">
                        <img src="assets/icons/et_icon.png" alt="Yiyecek">
                        <span>${cost.food} Yiyecek</span>
                     </div>`;
        }
        
        html += '</div>';
        
        tooltip.innerHTML = html;
        tooltip.style.display = 'block';
        updateTooltipPosition(event);
    }

    function updateTooltipPosition(event) {
        const tooltip = document.getElementById('tooltip');
        const x = event.clientX + 10;
        const y = event.clientY + 10;
        
        // Ekran sÄ±nÄ±rlarÄ±nÄ± kontrol et
        const maxX = window.innerWidth - tooltip.offsetWidth - 10;
        const maxY = window.innerHeight - tooltip.offsetHeight - 10;
        
        tooltip.style.left = Math.min(x, maxX) + 'px';
        tooltip.style.top = Math.min(y, maxY) + 'px';
    }

    function hideTooltip() {
        const tooltip = document.getElementById('tooltip');
        tooltip.style.display = 'none';
    }

    // YENÄ°: Kamera merkezleme fonksiyonu
    function centerCameraOnTown() {
        const townCenter = { x: 10, y: 10 };
        const screenCenter = isoToScreen(townCenter.x, townCenter.y);
        
        // Kamera pozisyonunu, kasaba merkezini ekranÄ±n ortasÄ±na gelecek ÅŸekilde ayarla
        S.cam.x = screenCenter.x - canvas.width / 2;
        S.cam.y = screenCenter.y - canvas.height / 2;
        
        console.log("Kamera merkeze yerleÅŸtirildi:", S.cam.x, S.cam.y);
    }

    window.addEventListener('load', function() {
        simulateLoading();
        setTimeout(() => {
            setupMenu();
            setupTooltips(); // YENÄ°: Tooltip sistemini baÅŸlat
            
            // YENÄ°: Loading ekranÄ± kapandÄ±ktan sonra kamerayÄ± merkeze al
            const checkLoading = setInterval(() => {
                if (loadingScreen.style.display === 'none') {
                    centerCameraOnTown();
                    clearInterval(checkLoading);
                }
            }, 100);
        }, 2000);
    });

    // YENÄ°: Canvas boyutu deÄŸiÅŸince de kamerayÄ± merkezle
    window.addEventListener('resize', function() {
        setTimeout(centerCameraOnTown, 100);
    });

    const canvas=document.getElementById('game');
    const ctx=canvas.getContext('2d');

    // YENÄ°: Kenardan kamera hareketi iÃ§in deÄŸiÅŸken
    const EDGE_SCROLL_MARGIN = 50; // Piksel cinsinden kenar mesafesi
    const EDGE_SCROLL_SPEED = 8; // Kamera kaydÄ±rma hÄ±zÄ± (15'ten 8'e dÃ¼ÅŸÃ¼rÃ¼ldÃ¼)

    let S={
      buildMode: null,
      cam: {x:0,y:0,z:1},
      mouse: {x:0,y:0,wx:0,wy:0},
      dragging: false,
      dragStart: {x:0,y:0},
      keys: {},
      map: [], walk: [],
      entities: [],
      trees: [],
      stones: [],
      deer: [],
      selection: new Set(),
      res: {food:100, wood:200, stone:100, gold:0},
      uid: 0,
      lastConstructionUpdate: 0,
      lastSelectedBuilding: null,
      lastResourceUpdate: 0,
      lastDeerUpdate: 0,
      // YENÄ°: AÄŸaÃ§ titreme efekti iÃ§in
      shakingTrees: new Set(),
      // SavaÅŸ sisi deÄŸiÅŸkenleri
      fogOfWar: [],
      explored: [],
      VISION_RANGE: 8
    };

    const TW=64, TH=32, MAP_W=50, MAP_H=50;
    const T_GRASS=0;

    function resize(){ canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
    window.addEventListener('resize',resize); resize();

    // YENÄ°: Kenardan kamera hareketi fonksiyonu
    function updateEdgeScroll() {
        const mouseX = S.mouse.x;
        const mouseY = S.mouse.y;
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        
        // Mouse ekranÄ±n dÄ±ÅŸÄ±ndaysa veya loading ekranÄ± gÃ¶steriliyorsa hareket etme
        if (mouseX < 0 || mouseX > canvasWidth || mouseY < 0 || mouseY > canvasHeight || 
            loadingScreen.style.display !== 'none') {
            return;
        }
        
        let scrollX = 0;
        let scrollY = 0;
        
        // Sol kenar
        if (mouseX < EDGE_SCROLL_MARGIN) {
            scrollX = -EDGE_SCROLL_SPEED;
        }
        // SaÄŸ kenar
        else if (mouseX > canvasWidth - EDGE_SCROLL_MARGIN) {
            scrollX = EDGE_SCROLL_SPEED;
        }
        
        // Ãœst kenar
        if (mouseY < EDGE_SCROLL_MARGIN) {
            scrollY = -EDGE_SCROLL_SPEED;
        }
        // Alt kenar
        else if (mouseY > canvasHeight - EDGE_SCROLL_MARGIN) {
            scrollY = EDGE_SCROLL_SPEED;
        }
        
        S.cam.x += scrollX;
        S.cam.y += scrollY;
    }

    // AÄŸaÃ§ resimlerini yÃ¼kle
    const treeImages = {
        type1: new Image(),
        type2: new Image(), 
        type3: new Image()
    };

    treeImages.type1.src = 'assets/images/trees/tree1.png';
    treeImages.type2.src = 'assets/images/trees/tree2.png';
    treeImages.type3.src = 'assets/images/trees/tree3.png';

    // TaÅŸ resimlerini yÃ¼kle
    const stoneImages = {
        type1: new Image(),
        type2: new Image(),
        type3: new Image()
    };

    stoneImages.type1.src = 'assets/images/stone/stone1.png';
    stoneImages.type2.src = 'assets/images/stone/stone2.png';
    stoneImages.type3.src = 'assets/images/stone/stone3.png';

    // Geyik resimlerini yÃ¼kle
    const deerImages = {
        alive: new Image(),
        dead: new Image()
    };

    deerImages.alive.src = 'assets/images/deer/deer.png';
    deerImages.dead.src = 'assets/images/deer/dead_deer.png';

    // YENÄ°: Bina gÃ¶rsellerini yÃ¼kle
    const buildingImages = {
        town: new Image(),
        house1: new Image(),
        house2: new Image(),
        lumberhouse: new Image(),
        hunterhouse: new Image(),
        stonehouse: new Image()
    };

    buildingImages.town.src = 'assets/images/build/ana_ev.png';
    buildingImages.house1.src = 'assets/images/build/house1.png';
    buildingImages.house2.src = 'assets/images/build/house2.png';
    buildingImages.lumberhouse.src = 'assets/images/build/oduncu.png';
    buildingImages.hunterhouse.src = 'assets/images/build/avci_evi.png';
    buildingImages.stonehouse.src = 'assets/images/build/tas_evi.png';

    // YENÄ°: SeÃ§im ikonlarÄ±nÄ± yÃ¼kle
    const selectionIcons = {
        tree: new Image(),
        town: new Image(),
        deer: new Image(),
        lumberhouse: new Image(),
        stonehouse: new Image(),
        house: new Image(),
        worker: new Image()
    };

    selectionIcons.tree.src = 'assets/icons/agac_icon.png';
    selectionIcons.town.src = 'assets/icons/ana_ev_icon.png';
    selectionIcons.deer.src = 'assets/icons/geyik_icon.png';
    selectionIcons.lumberhouse.src = 'assets/icons/oduncu_icon.png';
    selectionIcons.stonehouse.src = 'assets/icons/tas_evi_icon.png';
    selectionIcons.house.src = 'assets/icons/house_icon.png';
    selectionIcons.worker.src = 'assets/icons/isci_icon.png';

    // YENÄ°: Ä°nÅŸa buton gÃ¶rsellerini yÃ¼kle
    const buildButtonImages = {
        house: new Image(),
        lumberhouse: new Image(),
        hunterhouse: new Image(),
        stonehouse: new Image()
    };

    buildButtonImages.house.src = 'assets/images/build/house1.png';
    buildButtonImages.lumberhouse.src = 'assets/images/build/oduncu.png';
    buildButtonImages.hunterhouse.src = 'assets/images/build/avci_evi.png';
    buildButtonImages.stonehouse.src = 'assets/images/build/tas_evi.png';

    function isoToScreen(wx,wy){
      const x=(wx-wy)*(TW/2)*S.cam.z + canvas.width/2 - S.cam.x;
      const y=(wx+wy)*(TH/2)*S.cam.z + canvas.height/2 - S.cam.y;
      return {x,y};
    }
    function screenToIsoWorld(sx,sy){
      const cx=sx-canvas.width/2+S.cam.x;
      const cy=sy-canvas.height/2+S.cam.y;
      const wx=((cx/S.cam.z)/(TW/2)+(cy/S.cam.z)/(TH/2))/2;
      const wy=((cy/S.cam.z)/(TH/2)-(cx/S.cam.z)/(TW/2))/2;
      return {wx,wy};
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randomFloat(min, max) {
      return Math.random() * (max - min) + min;
    }

    function generateTrees() {
      S.trees = [];
      const totalTrees = 80;

      // ANA EVÄ°N ETRAFINDA GÃœVENLÄ° BÃ–LGE - DEÄžÄ°ÅžTÄ°RÄ°LDÄ° (daha az uzak)
      const TOWN_SAFE_RADIUS = 5; // Ana evden 5 birim uzakta olsunlar (8'den 5'e dÃ¼ÅŸÃ¼rÃ¼ldÃ¼)
      const TOWN_X = 10, TOWN_Y = 10; // Ana ev konumu
      
      const clusters = 12; //KÃœME (GRUP) adedi
      for (let i = 0; i < clusters; i++) {
        let clusterX, clusterY;
        let attempts = 0;
        
        // Ana evden uzak kÃ¼me merkezi bul
        do {
          clusterX = randomInt(3, MAP_W - 4); // SÄ±nÄ±rlarÄ± daralttÄ±k
          clusterY = randomInt(3, MAP_H - 4);
          attempts++;
        } while (Math.hypot(clusterX - TOWN_X, clusterY - TOWN_Y) < TOWN_SAFE_RADIUS && attempts < 50);
        
        const clusterSize = randomInt(30, 50);   // kÃ¼medeki aÄŸaÃ§ sayÄ±sÄ±
        
        for (let j = 0; j < clusterSize; j++) {
          const x = clusterX + randomInt(-3, 3);
          const y = clusterY + randomInt(-3, 3);
          
          // AÄŸaÃ§larÄ±n harita sÄ±nÄ±rlarÄ± ve ana evden uzak olmasÄ±nÄ± saÄŸla
          if (x >= 2 && x < MAP_W - 2 && 
              y >= 2 && y < MAP_H - 2 &&
              Math.hypot(x - TOWN_X, y - TOWN_Y) >= TOWN_SAFE_RADIUS) {
          
            const tooClose = S.trees.some(tree => 
              Math.abs(tree.x - x) < 1 && Math.abs(tree.y - y) < 1
            );
            
            if (!tooClose) {
              S.trees.push({
                x: x,
                y: y,
                type: randomInt(1, 3),
                wood: 200,
                isBeingChopped: false,
                choppingWorkers: []
              });
            }
          }
        }
      }
      
      const scatteredTrees = 80;   // ... daÄŸÄ±nÄ±k aÄŸaÃ§ sayÄ±sÄ±
      for (let i = 0; i < scatteredTrees; i++) {
        let x, y;
        let attempts = 0;
        
        // Ana evden uzak daÄŸÄ±nÄ±k aÄŸaÃ§lar
        do {
          x = randomInt(2, MAP_W - 3); // SÄ±nÄ±rlarÄ± daralttÄ±k
          y = randomInt(2, MAP_H - 3);
          attempts++;
        } while (Math.hypot(x - TOWN_X, y - TOWN_Y) < TOWN_SAFE_RADIUS && attempts < 50);
        
        const tooClose = S.trees.some(tree => 
          Math.abs(tree.x - x) < 2 && Math.abs(tree.y - y) < 2
        );
        
        if (!tooClose) {
          S.trees.push({
            x: x,
            y: y,
            type: randomInt(1, 3),
            wood: 200,
            isBeingChopped: false,
            choppingWorkers: []
          });
        }
      }
    }

    function generateStones() {
      S.stones = [];
      const totalStones = 4;
      
      // ANA EVÄ°N ETRAFINDA GÃœVENLÄ° BÃ–LGE - DEÄžÄ°ÅžTÄ°RÄ°LDÄ° (daha az uzak)
      const TOWN_SAFE_RADIUS = 5; // 8'den 5'e dÃ¼ÅŸÃ¼rÃ¼ldÃ¼
      const TOWN_X = 10, TOWN_Y = 10;
      
      for (let i = 0; i < totalStones; i++) {
        let placed = false;
        let attempts = 0;
        
        while (!placed && attempts < 100) {
          const x = randomInt(3, MAP_W - 4); // SÄ±nÄ±rlarÄ± daralttÄ±k
          const y = randomInt(3, MAP_H - 4);
          
          // Ana evden uzak olma kontrolÃ¼ EKLENDÄ°
          const tooCloseToTown = Math.hypot(x - TOWN_X, y - TOWN_Y) < TOWN_SAFE_RADIUS;
          const tooCloseToTree = S.trees.some(tree => 
            Math.abs(tree.x - x) < 3 && Math.abs(tree.y - y) < 3
          );
          
          const tooCloseToOtherStone = S.stones.some(stone => 
            Math.abs(stone.x - x) < 5 && Math.abs(stone.y - y) < 5
          );
          
          if (!tooCloseToTown && !tooCloseToTree && !tooCloseToOtherStone) {
            S.stones.push({
              x: x,
              y: y,
              type: randomInt(1, 3),
              stone: 200,
              isBeingMined: false,
              miningWorkers: []
            });
            placed = true;
          }
          
          attempts++;
        }
      }
    }

    function generateDeer() {
      S.deer = [];
      const herdCount = 5;
      const deerPerHerd = 5;
      
      console.log("Geyikler oluÅŸturuluyor...");
      
      // ANA EVÄ°N ETRAFINDA GÃœVENLÄ° BÃ–LGE - DEÄžÄ°ÅžTÄ°RÄ°LDÄ° (daha az uzak)
      const TOWN_SAFE_RADIUS = 6; // Geyikler 6 birim uzakta olsun (10'dan 6'ya dÃ¼ÅŸÃ¼rÃ¼ldÃ¼)
      const TOWN_X = 10, TOWN_Y = 10;
      
      for (let herd = 0; herd < herdCount; herd++) {
        let placedHerd = false;
        let attempts = 0;
        
        while (!placedHerd && attempts < 100) {
          const herdCenterX = randomInt(8, MAP_W - 9); // SÄ±nÄ±rlarÄ± daralttÄ±k
          const herdCenterY = randomInt(8, MAP_H - 9);
          
          // Ana evden uzak olma kontrolÃ¼ EKLENDÄ°
          const tooCloseToTown = Math.hypot(herdCenterX - TOWN_X, herdCenterY - TOWN_Y) < TOWN_SAFE_RADIUS;
          const tooCloseToTree = S.trees.some(tree => 
            Math.abs(tree.x - herdCenterX) < 4 && Math.abs(tree.y - herdCenterY) < 4
          );
          
          const tooCloseToStone = S.stones.some(stone => 
            Math.abs(stone.x - herdCenterX) < 4 && Math.abs(stone.y - herdCenterY) < 4
          );
          
          const tooCloseToOtherHerd = S.deer.some(deer => 
            Math.abs(deer.herdCenterX - herdCenterX) < 10 && Math.abs(deer.herdCenterY - herdCenterY) < 10
          );
          
          if (!tooCloseToTown && !tooCloseToTree && !tooCloseToStone && !tooCloseToOtherHerd) {
            for (let i = 0; i < deerPerHerd; i++) {
              const wanderRadius = 4;
              const x = herdCenterX + randomFloat(-wanderRadius, wanderRadius);
              const y = herdCenterY + randomFloat(-wanderRadius, wanderRadius);
              
              S.deer.push({
                id: nextId(),
                x: Math.max(1, Math.min(MAP_W-1, x)),
                y: Math.max(1, Math.min(MAP_H-1, y)),
                herdCenterX: herdCenterX,
                herdCenterY: herdCenterY,
                wanderRadius: wanderRadius,
                tx: x,
                ty: y,
                state: 'idle',
                stateTimer: randomInt(5000, 10000),
                speed: 0.5,
                lastMoveTime: 0,
                health: 200,
                maxHealth: 200,
                meat: 200,
                maxMeat: 200,
                isBeingHunted: false,
                huntingWorkers: [],
                isFleeing: false,
                fleeTarget: null,
                normalState: 'idle',
                normalStateTimer: 0,
                isDead: false,
                direction: 1 // 1: saÄŸa, -1: sola
              });
            }
            placedHerd = true;
            console.log(`SÃ¼rÃ¼ ${herd+1} konumu: (${herdCenterX}, ${herdCenterY})`);
          }
          
          attempts++;
        }
      }
      
      console.log(`${S.deer.length} geyik oluÅŸturuldu`);
    }

    // YENÄ°: AÄŸaÃ§ titreme Ã§izim fonksiyonu
    function drawTreeWithShake(ctx, tree, sx, sy) {
        let treeImage;
        if(tree.type === 1) treeImage = treeImages.type1;
        else if(tree.type === 2) treeImage = treeImages.type2;
        else treeImage = treeImages.type3;
        
        // Titreme efekti
        let shakeX = 0;
        let shakeY = 0;
        
        if (S.shakingTrees.has(tree)) {
            // Rastgele titreme (hafif)
            shakeX = (Math.random() - 0.5) * 3 * S.cam.z;
            shakeY = (Math.random() - 0.5) * 1.5 * S.cam.z;
        }
        
        if(treeImage && treeImage.complete) {
            ctx.drawImage(
                treeImage, 
                sx - 24*S.cam.z + shakeX,
                sy - 48*S.cam.z + shakeY,
                48*S.cam.z,
                48*S.cam.z
            );
        }

        if(S.selection.has('tree_' + S.trees.indexOf(tree))) {
            ctx.strokeStyle = 'cyan';
            ctx.beginPath();
            ctx.arc(sx + shakeX, sy - 24*S.cam.z + shakeY, 12*S.cam.z, 0, Math.PI*2);
            ctx.stroke();
        }
    }

    // SavaÅŸ sisi haritasÄ±nÄ± baÅŸlat
    function initFogOfWar() {
      S.fogOfWar = [];
      S.explored = [];
      for(let y = 0; y < MAP_H; y++) {
        S.fogOfWar[y] = [];
        S.explored[y] = [];
        for(let x = 0; x < MAP_W; x++) {
          S.fogOfWar[y][x] = true; // BaÅŸlangÄ±Ã§ta her yer kapalÄ±
          S.explored[y][x] = false; // HiÃ§bir yer keÅŸfedilmemiÅŸ
        }
      }
      
      // Ana ev etrafÄ±nÄ± aÃ§
      const TOWN_X = 10, TOWN_Y = 10;
      for(let y = TOWN_Y - 5; y <= TOWN_Y + 5; y++) {
        for(let x = TOWN_X - 5; x <= TOWN_X + 5; x++) {
          if(x >= 0 && x < MAP_W && y >= 0 && y < MAP_H) {
            S.fogOfWar[y][x] = false;
            S.explored[y][x] = true;
          }
        }
      }
    }

    function updateFogOfWar() {
      // Ã–nce tÃ¼m gÃ¶rÃ¼ÅŸ alanÄ±nÄ± kapat (keÅŸfedilmiÅŸ yerler hariÃ§)
      for(let y = 0; y < MAP_H; y++) {
        for(let x = 0; x < MAP_W; x++) {
          if(S.explored[y][x]) {
            S.fogOfWar[y][x] = true; // KeÅŸfedilmiÅŸ ama ÅŸu an gÃ¶rÃ¼nmeyen
          }
        }
      }
      
      // Ä°ÅŸÃ§ilerin gÃ¶rÃ¼ÅŸ alanÄ±nÄ± aÃ§
      S.entities.forEach(entity => {
        if(entity.kind === 'worker') {
          updateVisionAt(entity.x, entity.y);
        }
      });
      
      // BinalarÄ±n gÃ¶rÃ¼ÅŸ alanÄ±nÄ± aÃ§ (inÅŸaat halinde olmayan)
      S.entities.forEach(entity => {
        if((entity.kind === 'town' || entity.kind === 'house1' || entity.kind === 'house2' || 
            entity.kind === 'lumberhouse' || entity.kind === 'hunterhouse' || entity.kind === 'stonehouse') &&
            !entity.isUnderConstruction) {
          updateVisionAt(entity.x, entity.y);
        }
      });
    }

    function updateVisionAt(centerX, centerY) {
      const range = S.VISION_RANGE;
      for(let y = Math.max(0, Math.floor(centerY - range)); y <= Math.min(MAP_H-1, Math.floor(centerY + range)); y++) {
        for(let x = Math.max(0, Math.floor(centerX - range)); x <= Math.min(MAP_W-1, Math.floor(centerX + range)); x++) {
          const dist = Math.hypot(x - centerX, y - centerY);
          if(dist <= range) {
            S.fogOfWar[y][x] = false;
            S.explored[y][x] = true;
          }
        }
      }
    }

    function findNearestWorker(x, y) {
      const workers = S.entities.filter(e => e.kind === 'worker');
      if (workers.length === 0) return null;
      
      let nearest = workers[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < workers.length; i++) {
        const dist = Math.hypot(workers[i].x - x, workers[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = workers[i];
        }
      }
      
      return { worker: nearest, distance: minDist };
    }

    function updateDeerBehavior(timestamp) {
      if (!S.lastDeerUpdate) S.lastDeerUpdate = timestamp;
      if (timestamp - S.lastDeerUpdate < 100) return;
      
      S.deer.forEach(deer => {
        // Ã–lÃ¼ geyikler hareket etmez
        if (deer.isDead) {
          deer.state = 'dead';
          deer.tx = deer.x;
          deer.ty = deer.y;
          return;
        }
        
        if (!deer.lastMoveTime) deer.lastMoveTime = timestamp;
        
        // Ä°ÅŸÃ§i kontrolÃ¼ - kaÃ§Ä±ÅŸ davranÄ±ÅŸÄ±
        const nearestWorker = findNearestWorker(deer.x, deer.y);
        const FLEE_DISTANCE = 8;
        const RETURN_DISTANCE = 12;
        
        if (nearestWorker && nearestWorker.distance < FLEE_DISTANCE && !deer.isFleeing) {
          // KaÃ§Ä±ÅŸ moduna geÃ§
          deer.isFleeing = true;
          deer.normalState = deer.state;
          deer.normalStateTimer = deer.stateTimer;
          
          // Ä°ÅŸÃ§iden uzaklaÅŸacak ÅŸekilde hedef belirle
          const angle = Math.atan2(deer.y - nearestWorker.worker.y, deer.x - nearestWorker.worker.x);
          const fleeDistance = 15;
          deer.tx = deer.x + Math.cos(angle) * fleeDistance;
          deer.ty = deer.y + Math.sin(angle) * fleeDistance;
          
          // Harita sÄ±nÄ±rlarÄ± iÃ§inde kal
          deer.tx = Math.max(1, Math.min(MAP_W-1, deer.tx));
          deer.ty = Math.max(1, Math.min(MAP_H-1, deer.ty));
          
        } else if (deer.isFleeing && (!nearestWorker || nearestWorker.distance > RETURN_DISTANCE)) {
          // GÃ¼vende, normal duruma dÃ¶n
          deer.isFleeing = false;
          deer.state = deer.normalState;
          deer.stateTimer = deer.normalStateTimer;
          deer.tx = deer.x;
          deer.ty = deer.y;
        }
        
        // KaÃ§Ä±ÅŸ durumu - Ã–NCELÄ°KLÄ°
        if (deer.isFleeing && !deer.isDead) {
          const dx = deer.tx - deer.x;
          const dy = deer.ty - deer.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist > 0.1) {
            // Alternatif basit Ã§Ã¶zÃ¼m - her hareket adÄ±mÄ±nda yÃ¶nÃ¼ gÃ¼ncelle
            const moveAngle = Math.atan2(dy, dx);
            deer.direction = Math.abs(moveAngle) < Math.PI/2 ? 1 : -1;
            
            const moveX = (dx / dist) * 0.03;
            const moveY = (dy / dist) * 0.03;
            
            deer.x += moveX;
            deer.y += moveY;
          } else {
            // KaÃ§Ä±ÅŸ hedefine ulaÅŸtÄ±, beklemeye geÃ§
            deer.tx = deer.x;
            deer.ty = deer.y;
          }
        } 
        // Normal davranÄ±ÅŸ (kaÃ§mÄ±yorsa ve Ã¶lÃ¼ deÄŸilse)
        else if (!deer.isFleeing && !deer.isDead) {
          const timeSinceLastMove = timestamp - deer.lastMoveTime;
          
          // Durum deÄŸiÅŸtirme kontrolÃ¼
          if (timeSinceLastMove > deer.stateTimer) {
            // Yeni durum seÃ§
            if (deer.state === 'idle') {
              // Dinlenmeden sonra hareket et
              deer.state = 'moving';
              deer.stateTimer = randomInt(3000, 6000);
              
              // Yeni hedef belirle - sÃ¼rÃ¼ merkezi etrafÄ±nda
              const angle = Math.random() * Math.PI * 2;
              const distance = randomFloat(2, 5);
              deer.tx = deer.herdCenterX + Math.cos(angle) * distance;
              deer.ty = deer.herdCenterY + Math.sin(angle) * distance;
              
              // Harita sÄ±nÄ±rlarÄ± iÃ§inde kal
              deer.tx = Math.max(1, Math.min(MAP_W-1, deer.tx));
              deer.ty = Math.max(1, Math.min(MAP_H-1, deer.ty));
              
            } else {
              // Hareketten sonra dinlen
              deer.state = 'idle';
              deer.stateTimer = randomInt(8000, 15000);
              deer.tx = deer.x;
              deer.ty = deer.y;
            }
            deer.lastMoveTime = timestamp;
          }
          
          // Hareket durumunda hedefe doÄŸru ilerle
          if (deer.state === 'moving') {
            const dx = deer.tx - deer.x;
            const dy = deer.ty - deer.y;
            const dist = Math.hypot(dx,dy);
            
            if (dist > 0.1) {
              // Alternatif basit Ã§Ã¶zÃ¼m - her hareket adÄ±mÄ±nda yÃ¶nÃ¼ gÃ¼ncelle
              const moveAngle = Math.atan2(dy, dx);
              deer.direction = Math.abs(moveAngle) < Math.PI/2 ? 1 : -1;
              
              const moveX = (dx / dist) * deer.speed * 0.03;
              const moveY = (dy /dist) * deer.speed * 0.03;
              
              deer.x += moveX;
              deer.y += moveY;
              
              // SÃ¼rÃ¼ merkezinden Ã§ok uzaklaÅŸmasÄ±n
              const distToCenter = Math.hypot(deer.x - deer.herdCenterX, deer.y - deer.herdCenterY);
              if (distToCenter > deer.wanderRadius * 2) {
                // Merkeze doÄŸru yÃ¶n deÄŸiÅŸtir
                const angleToCenter = Math.atan2(deer.herdCenterY - deer.y, deer.herdCenterX - deer.x);
                deer.tx = deer.herdCenterX + Math.cos(angleToCenter) * randomFloat(1, 3);
                deer.ty = deer.herdCenterY + Math.sin(angleToCenter) * randomFloat(1, 3);
              }
            } else {
              // Hedefe ulaÅŸtÄ±, dinlenmeye geÃ§
              deer.state = 'idle';
              deer.stateTimer = randomInt(8000, 15000);
            }
          }
        }
      });
      
      S.lastDeerUpdate = timestamp;
    }

    function findNearestLumberhouse(x, y) {
      const lumberhouses = S.entities.filter(e => e.kind === 'lumberhouse' && !e.isUnderConstruction);
      if (lumberhouses.length === 0) return null;
      
      let nearest = lumberhouses[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < lumberhouses.length; i++) {
        const dist = Math.hypot(lumberhouses[i].x - x, lumberhouses[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = lumberhouses[i];
        }
      }
      
      return nearest;
    }

    function findNearestStonehouse(x, y) {
      const stonehouses = S.entities.filter(e => e.kind === 'stonehouse' && !e.isUnderConstruction);
      if (stonehouses.length === 0) return null;
      
      let nearest = stonehouses[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < stonehouses.length; i++) {
        const dist = Math.hypot(stonehouses[i].x - x, stonehouses[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = stonehouses[i];
        }
      }
      
      return nearest;
    }

    function findNearestHunterhouse(x, y) {
      const hunterhouses = S.entities.filter(e => e.kind === 'hunterhouse' && !e.isUnderConstruction);
      if (hunterhouses.length === 0) return null;
      
      let nearest = hunterhouses[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < hunterhouses.length; i++) {
        const dist = Math.hypot(hunterhouses[i].x - x, hunterhouses[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = hunterhouses[i];
        }
      }
      
      return nearest;
    }

    function findNearestTree(x, y) {
      const availableTrees = S.trees.filter(tree => tree.wood > 0);
      if (availableTrees.length === 0) return null;
      
      let nearest = availableTrees[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < availableTrees.length; i++) {
        const dist = Math.hypot(availableTrees[i].x - x, availableTrees[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = availableTrees[i];
        }
      }
      
      return nearest;
    }

    function findNearestStone(x, y) {
      const availableStones = S.stones.filter(stone => stone.stone > 0);
      if (availableStones.length === 0) return null;
      
      let nearest = availableStones[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < availableStones.length; i++) {
        const dist = Math.hypot(availableStones[i].x - x, availableStones[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = availableStones[i];
        }
      }
      
      return nearest;
    }

    function findNearestDeer(x, y) {
      const availableDeer = S.deer.filter(deer => !deer.isDead);
      if (availableDeer.length === 0) return null;
      
      let nearest = availableDeer[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < availableDeer.length; i++) {
        const dist = Math.hypot(availableDeer[i].x - x, availableDeer[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = availableDeer[i];
        }
      }
      
      return nearest;
    }

    function findNearestDeadDeer(x, y) {
      const deadDeer = S.deer.filter(deer => deer.isDead && deer.meat > 0);
      if (deadDeer.length === 0) return null;
      
      let nearest = deadDeer[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < deadDeer.length; i++) {
        const dist = Math.hypot(deadDeer[i].x - x, deadDeer[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = deadDeer[i];
        }
      }
      
      return nearest;
    }

    function findNearestStorage(x, y, resourceType = 'wood') {
      if (resourceType === 'wood') {
        const lumberhouse = findNearestLumberhouse(x, y);
        if (lumberhouse) return lumberhouse;
      } else if (resourceType === 'stone') {
        const stonehouse = findNearestStonehouse(x, y);
        if (stonehouse) return stonehouse;
      } else if (resourceType === 'meat') {
        const hunterhouse = findNearestHunterhouse(x, y);
        if (hunterhouse) return hunterhouse;
      }
      
      const towns = S.entities.filter(e => e.kind === 'town' && !e.isUnderConstruction);
      if (towns.length === 0) return null;
      
      let nearest = towns[0];
      let minDist = Math.hypot(nearest.x - x, nearest.y - y);
      
      for (let i = 1; i < towns.length; i++) {
        const dist = Math.hypot(towns[i].x - x, towns[i].y - y);
        if (dist < minDist) {
          minDist = dist;
          nearest = towns[i];
        }
      }
      
      return nearest;
    }

    // YENÄ°: En yakÄ±n boÅŸta Ã§alÄ±ÅŸan iÅŸÃ§iyi bulma fonksiyonu - GÃœNCELLENDÄ°
    function findNearestIdleWorker(x, y) {
        const allWorkers = S.entities.filter(worker => worker.kind === 'worker');
        
        if (allWorkers.length === 0) return null;
        
        // Ã–nce boÅŸta olan iÅŸÃ§ileri bul
        let idleWorkers = allWorkers.filter(worker => 
            !worker.isConstructing && 
            !worker.isChopping && 
            !worker.isMining && 
            !worker.isHunting && 
            !worker.isCollectingMeat && 
            !worker.isDelivering && 
            !worker.isDeliveringToBuilding
        );
        
        // EÄŸer boÅŸ iÅŸÃ§i yoksa, en yakÄ±n iÅŸÃ§iyi bul ve gÃ¶revini iptal et
        if (idleWorkers.length === 0) {
            console.log("BoÅŸ iÅŸÃ§i yok, en yakÄ±n iÅŸÃ§i gÃ¶revden alÄ±nÄ±yor...");
            
            let nearestWorker = allWorkers[0];
            let minDist = Math.hypot(nearestWorker.x - x, nearestWorker.y - y);
            
            for (let i = 1; i < allWorkers.length; i++) {
                const dist = Math.hypot(allWorkers[i].x - x, allWorkers[i].y - y);
                if (dist < minDist) {
                    minDist = dist;
                    nearestWorker = allWorkers[i];
                }
            }
            
            // Ä°ÅŸÃ§inin mevcut gÃ¶revlerini temizle
            clearWorkerTasks(nearestWorker);
            return nearestWorker;
        }
        
        // BoÅŸ iÅŸÃ§i varsa en yakÄ±nÄ±nÄ± bul
        let nearestIdleWorker = idleWorkers[0];
        let minDist = Math.hypot(nearestIdleWorker.x - x, nearestIdleWorker.y - y);
        
        for (let i = 1; i < idleWorkers.length; i++) {
            const dist = Math.hypot(idleWorkers[i].x - x, idleWorkers[i].y - y);
            if (dist < minDist) {
                minDist = dist;
                nearestIdleWorker = idleWorkers[i];
            }
        }
        
        return nearestIdleWorker;
    }

    // YENÄ°: Ä°ÅŸÃ§inin tÃ¼m gÃ¶revlerini temizleme fonksiyonu
    function clearWorkerTasks(worker) {
        console.log(`Ä°ÅŸÃ§i ${worker.id} gÃ¶revleri temizleniyor...`);
        
        // AÄŸaÃ§ kesme gÃ¶revini temizle
        if (worker.isChopping) {
            const tree = worker.isChopping;
            tree.choppingWorkers = tree.choppingWorkers.filter(id => id !== worker.id);
            worker.isChopping = null;
        }
        
        // TaÅŸ Ã§Ä±karma gÃ¶revini temizle
        if (worker.isMining) {
            const stone = worker.isMining;
            stone.miningWorkers = stone.miningWorkers.filter(id => id !== worker.id);
            worker.isMining = null;
        }
        
        // Geyik avlama gÃ¶revini temizle
        if (worker.isHunting) {
            const deer = worker.isHunting;
            deer.huntingWorkers = deer.huntingWorkers.filter(id => id !== worker.id);
            worker.isHunting = null;
        }
        
        // Et toplama gÃ¶revini temizle
        if (worker.isCollectingMeat) {
            worker.isCollectingMeat = null;
        }
        
        // Teslimat gÃ¶revini temizle
        if (worker.isDelivering) {
            worker.isDelivering = false;
        }
        
        // Binaya teslimat gÃ¶revini temizle
        if (worker.isDeliveringToBuilding) {
            worker.isDeliveringToBuilding = null;
        }
        
        // Ä°nÅŸaat gÃ¶revini temizle
        if (worker.isConstructing) {
            const building = S.entities.find(b => b.id === worker.isConstructing);
            if (building && building.constructionWorkers) {
                building.constructionWorkers = building.constructionWorkers.filter(id => id !== worker.id);
            }
            worker.isConstructing = null;
        }
        
        console.log(`Ä°ÅŸÃ§i ${worker.id} artÄ±k boÅŸta`);
    }

    for(let y=0;y<MAP_H;y++){
      S.map[y]=[]; S.walk[y]=[];
      for(let x=0;x<MAP_W;x++){ S.map[y][x]=T_GRASS; S.walk[y][x]=true; }
    }

    // Ã–NCE ANA EVI EKLE
    S.entities.push({
      id:1, 
      kind:'town', 
      x:10, y:10, 
      health:100, 
      maxHealth:100,
      constructionProgress:100,
      isUnderConstruction:false
    });

    // SONRA AÄžAÃ‡, TAÅž VE GEYÄ°KLERÄ° OLUÅžTUR (ana evden uzak olacaklar)
    generateTrees();
    generateStones();
    generateDeer();
    initFogOfWar();

    S.uid = Math.max(S.uid, ...S.entities.map(e => e.id), ...S.deer.map(d => d.id));

    function nextId(){ S.uid+=1; return S.uid; }

    // YENÄ°: SeÃ§ili binayÄ± silme fonksiyonu
    function deleteSelectedBuilding() {
        if (S.selection.size !== 1) return;
        
        const selectedId = [...S.selection][0];
        const selectedEntity = S.entities.find(e => e.id === selectedId);
        
        // Sadece binalarÄ± sil (worker'larÄ± ve town'u silme)
        if (selectedEntity && 
            (selectedEntity.kind === 'house1' || 
             selectedEntity.kind === 'house2' || 
             selectedEntity.kind === 'lumberhouse' || 
             selectedEntity.kind === 'hunterhouse' || 
             selectedEntity.kind === 'stonehouse')) {
            
            // Kaynak iadesi (isteÄŸe baÄŸlÄ± - binanÄ±n maliyetinin yarÄ±sÄ±nÄ± iade edelim)
            let refundAmount = 0;
            if (selectedEntity.kind === 'house1' || selectedEntity.kind === 'house2' || 
                selectedEntity.kind === 'lumberhouse' || selectedEntity.kind === 'hunterhouse') {
                refundAmount = 25; // 50 odunun yarÄ±sÄ±
                S.res.wood += refundAmount;
            } else if (selectedEntity.kind === 'stonehouse') {
                refundAmount = 37; // 75 odunun yarÄ±sÄ±
                S.res.wood += refundAmount;
            }
            
            // BinayÄ± entity listesinden kaldÄ±r
            const index = S.entities.findIndex(e => e.id === selectedId);
            if (index > -1) {
                S.entities.splice(index, 1);
            }
            
            // SeÃ§imi temizle
            S.selection.clear();
            
            // UI'Ä± gÃ¼ncelle
            updateTopBar();
            updatePopulation();
            updateSelectionCard();
            
            console.log(`Bina silindi. ${refundAmount} odun iade edildi.`);
        }
    }

    // KAMERA BAÅžLANGIÃ‡ POZÄ°SYONU - centerCameraOnTown() FONKSÄ°YONU BUNU YÃ–NETECEK
    S.cam.x = 0;
    S.cam.y = 0;

    // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: Capslock'tan etkilenmeyen tuÅŸ kontrolÃ¼ - Delete tuÅŸu eklendi
    window.addEventListener('keydown',e=>{ 
      const key = e.key.toLowerCase();
      S.keys[key]=true; 
      
      // Ok tuÅŸlarÄ± iÃ§in ek kontrol
      if (e.key === 'ArrowUp') S.keys['arrowup'] = true;
      if (e.key === 'ArrowDown') S.keys['arrowdown'] = true;
      if (e.key === 'ArrowLeft') S.keys['arrowleft'] = true;
      if (e.key === 'ArrowRight') S.keys['arrowright'] = true;
      
      // YENÄ°: Delete tuÅŸu ile bina silme
      if (e.key === 'Delete') {
        deleteSelectedBuilding();
      }
    });
    
    window.addEventListener('keyup',e=>{ 
      const key = e.key.toLowerCase();
      S.keys[key]=false; 
      
      // Ok tuÅŸlarÄ± iÃ§in ek kontrol
      if (e.key === 'ArrowUp') S.keys['arrowup'] = false;
      if (e.key === 'ArrowDown') S.keys['arrowdown'] = false;
      if (e.key === 'ArrowLeft') S.keys['arrowleft'] = false;
      if (e.key === 'ArrowRight') S.keys['arrowright'] = false;
    });

    canvas.addEventListener('mousemove',e=>{
      S.mouse.x=e.clientX; S.mouse.y=e.clientY;
      const {wx,wy}=screenToIsoWorld(e.clientX,e.clientY);
      S.mouse.wx=wx; S.mouse.wy=wy;
    });
    canvas.addEventListener('mousedown',e=>{
      if(e.button===0){
        if(S.buildMode){
          const x=Math.floor(S.mouse.wx);
          const y=Math.floor(S.mouse.wy);
          
          let canBuild = true;
          
          // Bina kontrolÃ¼
          for(const entity of S.entities){
            if(entity.kind === 'town' || entity.kind === 'house1' || entity.kind === 'house2' || 
               entity.kind === 'lumberhouse' || entity.kind === 'hunterhouse' ||
               entity.kind === 'stonehouse'){
              if(Math.floor(entity.x) === x && Math.floor(entity.y) === y){
                canBuild = false;
                break;
              }
            }
          }
          
          // AÄŸaÃ§ kontrolÃ¼
          if(canBuild){
            for(const tree of S.trees){
              if(Math.floor(tree.x) === x && Math.floor(tree.y) === y){
                canBuild = false;
                break;
              }
            }
          }
          
          // TaÅŸ kontrolÃ¼
          if(canBuild){
            for(const stone of S.stones){
              if(Math.floor(stone.x) === x && Math.floor(stone.y) === y){
                canBuild = false;
                break;
              }
            }
          }
          
          // Geyik kontrolÃ¼ EKLENDÄ°
          if(canBuild){
            for(const deer of S.deer){
              if(Math.floor(deer.x) === x && Math.floor(deer.y) === y){
                canBuild = false;
                break;
              }
            }
          }
          
          let cost = 0;
          if(S.buildMode==='house1' || S.buildMode==='house2' || S.buildMode==='lumberhouse' || S.buildMode==='hunterhouse'){
            cost = 50;
          } else if(S.buildMode==='stonehouse'){
            cost = 75;
          }
          
          if(canBuild && S.res.wood>=cost){
            const newId=nextId();
            // YENÄ° BÄ°NAYI OLUÅžTUR
            const newBuilding = {
              id:newId, 
              kind: S.buildMode,
              x, y, 
              health:100, 
              maxHealth:100,
              constructionProgress:0,
              isUnderConstruction:true,
              constructionWorkers:[]
            };
            S.entities.push(newBuilding);
            S.res.wood-=cost;
            updateTopBar();
            
            // YENÄ°: Bina yerleÅŸtirme sesi
            playSoundEffect('buildSound');
            
            // YENÄ°: EN YAKIN BOÅžTA OLAN Ä°ÅžÃ‡Ä°YÄ° BUL VE HEMEN Ä°NÅžAATA GÃ–NDER
            const nearestIdleWorker = findNearestIdleWorker(x, y);
            if (nearestIdleWorker) {
              sendWorkersToConstruction(newBuilding, [nearestIdleWorker]);
              console.log(`Ä°ÅŸÃ§i ${nearestIdleWorker.id} hemen inÅŸaata gÃ¶nderildi!`);
            } else {
              console.log("BoÅŸta iÅŸÃ§i bulunamadÄ±, bina bekliyor...");
            }
          }
          S.buildMode=null;
          return;
        }
        S.dragging=true;
        S.dragStart={x:e.clientX,y:e.clientY};
      }
    });
    canvas.addEventListener('mouseup',e=>{ if(e.button===0){ S.dragging=false; commitSelection(); } });
    
    // GÃœNCELLENMÄ°Åž: GENÄ°ÅžLETÄ°LMÄ°Åž TIKLAMA ALANI - BÄ°NA GÃ–RSELÄ°NE TIKLAMA EKLENDÄ°
    canvas.addEventListener('contextmenu',e=>{ 
      e.preventDefault(); 
      
      const {wx,wy}=screenToIsoWorld(e.clientX,e.clientY);
      
      // GENÄ°ÅžLETÄ°LMÄ°Åž TIKLAMA ALANI - grid kontrolÃ¼ yerine gÃ¶rsel merkezine gÃ¶re
      let clickedTree = null;
      let clickedStone = null;
      let clickedDeer = null;
      let clickedDeadDeer = null;
      let clickedBuilding = null;
      let clickedConstructionBuilding = null;
      
      // BÄ°NALAR - GÃ–RSEL MERKEZÄ°NE GÃ–RE KONTROL (DEÄžÄ°ÅžTÄ°RÄ°LDÄ°)
      for(const entity of S.entities){
        if(entity.kind === 'town' || entity.kind === 'house1' || entity.kind === 'house2' || 
           entity.kind === 'lumberhouse' || entity.kind === 'hunterhouse' || entity.kind === 'stonehouse'){
          
          const s=isoToScreen(entity.x,entity.y);
          const d=Math.hypot(e.clientX-s.x,e.clientY-s.y);
          
          // Bina gÃ¶rselinin merkezine tÄ±klama (daha geniÅŸ alan)
          if(d < 40) {
            if(entity.isUnderConstruction){
              clickedConstructionBuilding = entity;
            } else {
              clickedBuilding = entity;
            }
            break;
          }
        }
      }
      
      // AÄžAÃ‡ - gÃ¶rsel merkezine gÃ¶re kontrol
      if(!clickedBuilding && !clickedConstructionBuilding){
        for(const tree of S.trees){
          const s=isoToScreen(tree.x,tree.y);
          const d=Math.hypot(e.clientX-s.x,e.clientY-s.y);
          if(d<40 && tree.wood > 0){
            clickedTree = tree;
            break;
          }
        }
      }
      
      // TAÅž - gÃ¶rsel merkezine gÃ¶re kontrol
      if(!clickedBuilding && !clickedConstructionBuilding && !clickedTree){
        for(const stone of S.stones){
          const s=isoToScreen(stone.x,stone.y);
          const d=Math.hypot(e.clientX-s.x,e.clientY-s.y);
          if(d<40 && stone.stone > 0){
            clickedStone = stone;
            break;
          }
        }
      }
      
      // GEYÄ°K - gÃ¶rsel merkezine gÃ¶re kontrol
      if(!clickedBuilding && !clickedConstructionBuilding && !clickedTree && !clickedStone){
        for(const deer of S.deer){
          const s=isoToScreen(deer.x,deer.y);
          const d=Math.hypot(e.clientX-s.x,e.clientY-s.y);
          if(d<40){
            if(!deer.isDead && deer.health > 0){
              clickedDeer = deer;
            } else if(deer.isDead && deer.meat > 0){
              clickedDeadDeer = deer;
            }
            break;
          }
        }
      }
      
      const selectedWorkers = [...S.selection].map(id => S.entities.find(e => e.id === id && e.kind === 'worker')).filter(Boolean);
      
      if(clickedTree && selectedWorkers.length > 0) {
        sendWorkersToTree(clickedTree, selectedWorkers);
      } else if(clickedStone && selectedWorkers.length > 0) {
        sendWorkersToStone(clickedStone, selectedWorkers);
      } else if(clickedDeer && selectedWorkers.length > 0) {
        sendWorkersToDeer(clickedDeer, selectedWorkers);
      } else if(clickedDeadDeer && selectedWorkers.length > 0) {
        sendWorkersToDeadDeer(clickedDeadDeer, selectedWorkers);
      } else if(clickedConstructionBuilding && selectedWorkers.length > 0) {
        sendWorkersToConstruction(clickedConstructionBuilding, selectedWorkers);
      } else if(clickedBuilding && selectedWorkers.length > 0) {
        sendWorkersToBuilding(clickedBuilding, selectedWorkers);
      } else {
        rightClickMove();
      }
    });

    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomFactor = 1.1;
      
      // Mouse'un mevcut dÃ¼nya koordinatlarÄ±nÄ± hesapla
      const worldBefore = screenToIsoWorld(e.clientX, e.clientY);
      
      // Zoom yap
      const oldZoom = S.cam.z;
      S.cam.z *= e.deltaY < 0 ? zoomFactor : 1/zoomFactor;
      if(S.cam.z < 0.3) S.cam.z = 0.3;
      if(S.cam.z > 2.0) S.cam.z = 2.0;
      
      // Zoom sonrasÄ± aynÄ± dÃ¼nya koordinatÄ±nÄ±n ekran pozisyonunu hesapla
      const screenAfter = isoToScreen(worldBefore.wx, worldBefore.wy);
      
      // KamerayÄ± ayarla - mouse pozisyonunu sabit tut
      S.cam.x += e.clientX - screenAfter.x;
      S.cam.y += e.clientY - screenAfter.y;
    });

    function sendWorkersToTree(tree, workers) {
      workers.forEach(worker => { 
        worker.tx = tree.x; 
        worker.ty = tree.y;
        worker.isChopping = tree;
        worker.isMining = null;
        worker.isHunting = null;
        worker.isCollectingMeat = null;
        worker.isDelivering = false;
        worker.carryingWood = worker.carryingWood || 0;
        worker.carryingStone = worker.carryingStone || 0;
        worker.carryingMeat = worker.carryingMeat || 0;
        
        if(!tree.choppingWorkers.includes(worker.id)) {
          tree.choppingWorkers.push(worker.id);
        }
      });
    }

    function sendWorkersToStone(stone, workers) {
      workers.forEach(worker => { 
        worker.tx = stone.x; 
        worker.ty = stone.y;
        worker.isMining = stone;
        worker.isChopping = null;
        worker.isHunting = null;
        worker.isCollectingMeat = null;
        worker.isDelivering = false;
        worker.carryingWood = worker.carryingWood || 0;
        worker.carryingStone = worker.carryingStone || 0;
        worker.carryingMeat = worker.carryingMeat || 0;
        
        if(!stone.miningWorkers.includes(worker.id)) {
          stone.miningWorkers.push(worker.id);
        }
      });
    }

    function sendWorkersToDeer(deer, workers) {
      workers.forEach(worker => { 
        worker.tx = deer.x; 
        worker.ty = deer.y;
        worker.isHunting = deer;
        worker.isChopping = null;
        worker.isMining = null;
        worker.isCollectingMeat = null;
        worker.isDelivering = false;
        worker.carryingWood = worker.carryingWood || 0;
        worker.carryingStone = worker.carryingStone || 0;
        worker.carryingMeat = worker.carryingMeat || 0;
        
        if(!deer.huntingWorkers.includes(worker.id)) {
          deer.huntingWorkers.push(worker.id);
        }
      });
    }

    function sendWorkersToDeadDeer(deer, workers) {
      workers.forEach(worker => { 
        worker.tx = deer.x; 
        worker.ty = deer.y;
        worker.isCollectingMeat = deer;
        worker.isChopping = null;
        worker.isMining = null;
        worker.isHunting = null;
        worker.isDelivering = false;
        worker.carryingWood = worker.carryingWood || 0;
        worker.carryingStone = worker.carryingStone || 0;
        worker.carryingMeat = worker.carryingMeat || 0;
      });
    }

    function sendWorkersToConstruction(building, workers) {
      workers.forEach(worker => { 
        worker.tx = building.x; 
        worker.ty = building.y;
        worker.isConstructing = building.id;
        worker.isChopping = null;
        worker.isMining = null;
        worker.isHunting = null;
        worker.isCollectingMeat = null;
        worker.isDelivering = false;
        
        if(!building.constructionWorkers.includes(worker.id)) {
          building.constructionWorkers.push(worker.id);
        }
      });
    }

    function sendWorkersToBuilding(building, workers) {
      workers.forEach(worker => { 
        worker.tx = building.x; 
        worker.ty = building.y;
        worker.isDeliveringToBuilding = building.id;
        worker.isChopping = null;
        worker.isMining = null;
        worker.isHunting = null;
        worker.isCollectingMeat = null;
        worker.isDelivering = false;
      });
    }
    
    function commitSelection(){
      S.selection.clear();
      let minx=Math.min(S.dragStart.x,S.mouse.x), miny=Math.min(S.dragStart.y,S.mouse.y);
      let maxx=Math.max(S.dragStart.x,S.mouse.x), maxy=Math.max(S.dragStart.y,S.mouse.y);
      const dragDist = Math.hypot(maxx-minx, maxy-miny);
      const BOX_THRESHOLD = 8;

      if(dragDist>BOX_THRESHOLD){
        const rectLeft=0, rectTop=0, rectRight=canvas.width, rectBottom=canvas.height;
        minx=Math.max(minx, rectLeft); maxx=Math.min(maxx, rectRight);
        miny=Math.max(miny, rectTop); maxy=Math.min(maxy, rectBottom);

        S.entities.forEach(e=>{
          const s=isoToScreen(e.x,e.y);
          if(s.x>=minx && s.x<=maxx && s.y>=miny && s.y<=maxy) S.selection.add(e.id);
        });
        
        S.deer.forEach(deer=>{
          const s=isoToScreen(deer.x,deer.y);
          if(s.x>=minx && s.x<=maxx && s.y>=miny && s.y<=maxy) S.selection.add('deer_' + S.deer.indexOf(deer));
        });
      } else {
        let hit=null, best=1e9;
        
        // GENÄ°ÅžLETÄ°LMÄ°Åž SEÃ‡Ä°M ALANI - BÄ°NALAR Ä°Ã‡Ä°N GÃ–RSEL MERKEZÄ°
        for(const entity of S.entities){
          if(entity.kind === 'town' || entity.kind === 'house1' || entity.kind === 'house2' || 
             entity.kind === 'lumberhouse' || entity.kind === 'hunterhouse' || entity.kind === 'stonehouse'){
            const s=isoToScreen(entity.x,entity.y);
            const d=Math.hypot(S.mouse.x-s.x,S.mouse.y-s.y);
            if(d<30 && d<best){ best=d; hit=entity; }
          }
        }
        
        if(!hit){
          for(const tree of S.trees){
            const s=isoToScreen(tree.x,tree.y);
            const d=Math.hypot(S.mouse.x-s.x,S.mouse.y-s.y);
            if(d<40 && d<best){ best=d; hit=tree; }
          }
        }
        
        if(!hit){
          for(const stone of S.stones){
            const s=isoToScreen(stone.x,stone.y);
            const d=Math.hypot(S.mouse.x-s.x,S.mouse.y-s.y);
            if(d<40 && d<best){ best=d; hit=stone; }
          }
        }
        
        if(!hit){
          for(const deer of S.deer){
            const s=isoToScreen(deer.x,deer.y);
            const d=Math.hypot(S.mouse.x-s.x,S.mouse.y-s.y);
            if(d<40 && d<best){ best=d; hit=deer; }
          }
        }
        
        if(!hit){
          for(const e of S.entities){
            if(e.kind!=='worker') continue;
            const s=isoToScreen(e.x,e.y);
            const d=Math.hypot(S.mouse.x-s.x,S.mouse.y-s.y);
            if(d<18 && d<best){ best=d; hit=e; }
          }
        }
        
        if(hit) {
          if(hit.kind) S.selection.add(hit.id);
          else if(hit.wood !== undefined) S.selection.add('tree_' + S.trees.indexOf(hit));
          else if(hit.stone !== undefined) S.selection.add('stone_' + S.stones.indexOf(hit));
          else if(hit.herdCenterX !== undefined) S.selection.add('deer_' + S.deer.indexOf(hit));
        }
      }
      updateSelectionCard();
    }

    function updateHealthDisplay(entity) {
      const healthContainer = document.getElementById('healthContainer');
      const healthPercent = document.getElementById('healthPercent');
      const healthBar = document.getElementById('healthBar');
      
      if(entity && entity.health !== undefined) {
        const percent = Math.round((entity.health / entity.maxHealth) * 100);
        healthPercent.textContent = percent;
        healthBar.style.width = percent + '%';
        
        if(percent > 70) {
          healthBar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
        } else if(percent > 30) {
          healthBar.style.background = 'linear-gradient(90deg, #FF9800, #FFC107)';
        } else {
          healthBar.style.background = 'linear-gradient(90deg, #F44336, #FF5722)';
        }
        
        healthContainer.style.display = 'block';
      } else {
        healthContainer.style.display = 'none';
      }
    }

    function updateWoodDisplay(woodAmount) {
      const woodContainer = document.getElementById('woodContainer');
      const woodAmountSpan = document.getElementById('woodAmount');
      const woodBar = document.getElementById('woodBar');
      
      const percent = Math.round((woodAmount / 200) * 100);
      woodAmountSpan.textContent = woodAmount;
      woodBar.style.width = percent + '%';
      woodContainer.style.display = 'block';
    }

    function updateStoneDisplay(stoneAmount) {
      const stoneContainer = document.getElementById('stoneContainer');
      const stoneAmountSpan = document.getElementById('stoneAmount');
      const stoneBar = document.getElementById('stoneBar');
      
      const percent = Math.round((stoneAmount / 200) * 100);
      stoneAmountSpan.textContent = stoneAmount;
      stoneBar.style.width = percent + '%';
      stoneContainer.style.display = 'block';
    }

    function updateDeerHealthDisplay(deer) {
      const deerHealthContainer = document.getElementById('deerHealthContainer');
      const deerHealthAmount = document.getElementById('deerHealthAmount');
      const deerHealthBar = document.getElementById('deerHealthBar');
      
      if(deer && deer.health !== undefined && !deer.isDead) {
        const percent = Math.round((deer.health / deer.maxHealth) * 100);
        deerHealthAmount.textContent = deer.health;
        deerHealthBar.style.width = percent + '%';
        
        if(percent > 70) {
          deerHealthBar.style.background = 'linear-gradient(90deg, #FF6B6B, #FF8E8E)';
        } else if(percent > 30) {
          deerHealthBar.style.background = 'linear-gradient(90deg, #FF5252, #FF7979)';
        } else {
          deerHealthBar.style.background = 'linear-gradient(90deg, #FF0000, #FF3333)';
        }
        
        deerHealthContainer.style.display = 'block';
      } else {
        deerHealthContainer.style.display = 'none';
      }
    }

    function updateDeerMeatDisplay(deer) {
      const deerMeatContainer = document.getElementById('deerMeatContainer');
      const deerMeatAmount = document.getElementById('deerMeatAmount');
      const deerMeatBar = document.getElementById('deerMeatBar');
      
      if(deer && deer.meat !== undefined && deer.isDead) {
        const percent = Math.round((deer.meat / deer.maxMeat) * 100);
        deerMeatAmount.textContent = deer.meat;
        deerMeatBar.style.width = percent + '%';
        deerMeatContainer.style.display = 'block';
      } else {
        deerMeatContainer.style.display = 'none';
      }
    }

    function updateConstructionDisplay(entity) {
      const constructionContainer = document.getElementById('constructionContainer');
      const constructionPercent = document.getElementById('constructionPercent');
      const constructionBar = document.getElementById('constructionBar');
      
      if(entity && entity.isUnderConstruction) {
        const percent = Math.round(entity.constructionProgress);
        constructionPercent.textContent = percent;
        constructionBar.style.width = percent + '%';
        constructionContainer.style.display = 'block';
        
        S.lastSelectedBuilding = entity.id;
      } else {
        constructionContainer.style.display = 'none';
        S.lastSelectedBuilding = null;
      }
    }

    function updateWorkerResourceDisplay(worker) {
      const workerResourceContainer = document.getElementById('workerResourceContainer');
      const workerWoodSpan = document.getElementById('workerWood');
      const workerStoneSpan = document.getElementById('workerStone');
      const workerMeatSpan = document.getElementById('workerMeat');
      
      if(worker) {
        workerWoodSpan.textContent = worker.carryingWood || 0;
        workerStoneSpan.textContent = worker.carryingStone || 0;
        workerMeatSpan.textContent = worker.carryingMeat || 0;
        workerResourceContainer.style.display = 'block';
      } else {
        workerResourceContainer.style.display = 'none';
      }
    }

    function updateSelectedBuildingDisplay() {
      if (S.lastSelectedBuilding) {
        const building = S.entities.find(e => e.id === S.lastSelectedBuilding);
        if (building && building.isUnderConstruction) {
          updateConstructionDisplay(building);
        }
      }
    }

    function updateSelectionCard(){
      const selInfo=document.getElementById('selectionInfo');
      const spawnContainer=document.getElementById('spawnBtnContainer');
      const commandCard=document.getElementById('commandCard');
      const healthContainer=document.getElementById('healthContainer');
      const woodContainer=document.getElementById('woodContainer');
      const stoneContainer=document.getElementById('stoneContainer');
      const deerHealthContainer=document.getElementById('deerHealthContainer');
      const deerMeatContainer=document.getElementById('deerMeatContainer');
      const constructionContainer=document.getElementById('constructionContainer');
      const workerResourceContainer=document.getElementById('workerResourceContainer');
      
      spawnContainer.innerHTML=''; 
      commandCard.style.display='none';
      healthContainer.style.display='none';
      woodContainer.style.display='none';
      stoneContainer.style.display='none';
      deerHealthContainer.style.display='none';
      deerMeatContainer.style.display='none';
      constructionContainer.style.display='none';
      workerResourceContainer.style.display='none';
      S.lastSelectedBuilding = null;
      
      if(!S.selection.size){ 
        selInfo.textContent='HiÃ§bir ÅŸey seÃ§ili deÄŸil.'; 
        return; 
      }

      const selectedWorkers=[...S.selection].map(id=>S.entities.find(x=>x.id===id && x.kind==='worker')).filter(Boolean);
      if(selectedWorkers.length) commandCard.style.display='block';

      if(S.selection.size===1){
        const id=[...S.selection][0];
        
        if(typeof id === 'string' && id.startsWith('tree_')) {
          const treeIndex = parseInt(id.split('_')[1]);
          const tree = S.trees[treeIndex];
          if(tree) {
            selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/agac_icon.png" class="selection-icon" alt="AÄŸaÃ§"><b>AÄŸaÃ§</b></div>';
            updateWoodDisplay(tree.wood);
          }
          return;
        }
        
        if(typeof id === 'string' && id.startsWith('stone_')) {
          const stoneIndex = parseInt(id.split('_')[1]);
          const stone = S.stones[stoneIndex];
          if(stone) {
            selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/tas_icon.png" class="selection-icon" alt="TaÅŸ"><b>TaÅŸ KaynaÄŸÄ±</b></div>';
            updateStoneDisplay(stone.stone);
          }
          return;
        }
        
        if(typeof id === 'string' && id.startsWith('deer_')) {
          const deerIndex = parseInt(id.split('_')[1]);
          const deer = S.deer[deerIndex];
          if(deer) {
            if(deer.isDead) {
              selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/geyik_icon.png" class="selection-icon" alt="Ã–lÃ¼ Geyik"><b>Ã–lÃ¼ Geyik</b></div>';
              updateDeerMeatDisplay(deer);
            } else {
              selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/geyik_icon.png" class="selection-icon" alt="Geyik"><b>Geyik</b></div>';
              updateDeerHealthDisplay(deer);
            }
          }
          return;
        }
        
        const e=S.entities.find(x=>x.id===id);
        if(!e){ selInfo.textContent='â€”'; return; }

        if(e.kind==='worker'){
          let status = 'BoÅŸta';
          if(e.isConstructing) status = 'Ä°nÅŸaatta Ã§alÄ±ÅŸÄ±yor';
          else if(e.isChopping) status = 'AÄŸaÃ§ kesiyor';
          else if(e.isMining) status = 'TaÅŸ Ã§Ä±karÄ±yor';
          else if(e.isHunting) status = 'Geyik avlÄ±yor';
          else if(e.isCollectingMeat) status = 'Et topluyor';
          else if(e.isDeliveringToBuilding) status = 'Binaya kaynak taÅŸÄ±yor';
          else if(e.isDelivering) status = (e.carryingWood ? 'Odun taÅŸÄ±yor' : e.carryingStone ? 'TaÅŸ taÅŸÄ±yor' : 'Et taÅŸÄ±yor');
          
          selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/isci_icon.png" class="selection-icon" alt="Ä°ÅŸÃ§i"><b>Ä°ÅŸÃ§i</b></div>Durum: ' + status;
          updateWorkerResourceDisplay(e);
        }
        else if(e.kind==='town'){
          selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/ana_ev_icon.png" class="selection-icon" alt="Kasaba Merkezi"><b>Kasaba Merkezi</b></div>';
          updateHealthDisplay(e);
          const btn=document.createElement('div');
          btn.className='btn';
          btn.innerHTML='<img src="assets/icons/isci_icon.png" class="resource-icon" alt="Ä°ÅŸÃ§i"> Ä°ÅŸÃ§i Ãœret (50 <img src="assets/icons/et_icon.png" class="resource-icon" alt="Et">)';
          btn.onclick=()=>{
            const currentWorkers=S.entities.filter(x=>x.kind==='worker').length;
            const houses=S.entities.filter(x=>(x.kind === 'house1' || x.kind === 'house2') && !x.isUnderConstruction).length;
            const maxPop=2 + houses*2;
            if(currentWorkers>=maxPop){
              alert('Ev yapman lazÄ±m!');
              return;
            }
            if(S.res.food<50){ alert('Yeterli yiyecek yok!'); return; }
            S.res.food-=50;
            const newId=nextId();
            S.entities.push({
              id:newId, 
              kind:'worker', 
              x:e.x+0.8, y:e.y, 
              tx:e.x+0.8, ty:e.y,
              carryingWood: 0,
              carryingStone: 0,
              carryingMeat: 0
            });
            updateTopBar(); updatePopulation();
          };
          spawnContainer.appendChild(btn);
        }
        else if(e.kind==='house1' || e.kind==='house2'){
          selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/house_icon.png" class="selection-icon" alt="Ev"><b>Ev</b></div>';
          updateHealthDisplay(e);
          if(e.isUnderConstruction) {
            updateConstructionDisplay(e);
          }
        }
        else if(e.kind==='lumberhouse'){
          selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/oduncu_icon.png" class="selection-icon" alt="Oduncu Evi"><b>Oduncu Evi</b></div>';
          updateHealthDisplay(e);
          if(e.isUnderConstruction) {
            updateConstructionDisplay(e);
          }
        }
        else if(e.kind==='hunterhouse'){
          selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/avci_evi_icon.png" class="selection-icon" alt="AvcÄ± Evi"><b>AvcÄ± Evi</b></div>';
          updateHealthDisplay(e);
          if(e.isUnderConstruction) {
            updateConstructionDisplay(e);
          }
        }
        else if(e.kind==='stonehouse'){
          selInfo.innerHTML='<div class="selection-header"><img src="assets/icons/tas_evi_icon.png" class="selection-icon" alt="TaÅŸ OcaÄŸÄ±"><b>TaÅŸ OcaÄŸÄ±</b></div>';
          updateHealthDisplay(e);
          if(e.isUnderConstruction) {
            updateConstructionDisplay(e);
          }
        }
      } else {
        selInfo.innerHTML=`<div class="selection-header"><img src="assets/icons/isci_icon.png" class="selection-icon" alt="SeÃ§im"><b>${S.selection.size} birim seÃ§ili</b></div>`;
      }
    }

    function updateTopBar(){
      document.getElementById('food').textContent=S.res.food;
      document.getElementById('wood').textContent=S.res.wood;
      document.getElementById('stone').textContent=S.res.stone;
      document.getElementById('gold').textContent=S.res.gold;
      updatePopulation();
    }

    function updatePopulation(){
      const currentWorkers=S.entities.filter(x=>x.kind==='worker').length;
      const houses=S.entities.filter(x=>(x.kind === 'house1' || x.kind === 'house2') && !x.isUnderConstruction).length;
      const maxPop=2 + houses*2;
      document.getElementById('popCur').textContent=currentWorkers;
      document.getElementById('popMax').textContent=maxPop;
    }

    function rightClickMove(){
      const {wx,wy}=S.mouse;
      const selectedWorkers=[...S.selection].map(id=>S.entities.find(e=>e.id===id && e.kind==='worker')).filter(Boolean);
      if(!selectedWorkers.length) return;

      const spacing=0.8, positions=[];
      const cols=Math.ceil(Math.sqrt(selectedWorkers.length));
      const rows=Math.ceil(selectedWorkers.length/cols);
      for(let i=0;i<selectedWorkers.length;i++){
        const col=i%cols;
        const row=Math.floor(i/cols);
        let tx=Math.floor(wx+(col-(cols-1)/2)*spacing);
        let ty=Math.floor(wy+(row-(rows-1)/2)*spacing);
        tx = Math.max(0, Math.min(MAP_W-1, tx));
        ty = Math.max(0, Math.min(MAP_H-1, ty));
        positions.push({tx,ty});
      }
      selectedWorkers.forEach((w,i)=>{ 
        w.tx=positions[i].tx; 
        w.ty=positions[i].ty;
        w.isConstructing = null;
        w.isChopping = null;
        w.isMining = null;
        w.isHunting = null;
        w.isCollectingMeat = null;
        w.isDelivering = false;
        w.isDeliveringToBuilding = null;
      });
    }

    const MOVE_SPEED=4;

    function updateConstruction(timestamp) {
      S.entities.forEach(building => {
        if(building.isUnderConstruction && building.constructionProgress < 100) {
          const activeWorkers = building.constructionWorkers.filter(workerId => {
            const worker = S.entities.find(w => w.id === workerId && w.kind === 'worker');
            return worker && Math.hypot(worker.x - building.x, worker.y - building.y) < 0.5;
          });
          
          if(activeWorkers.length > 0 && timestamp - building.lastProgressUpdate > 1000) {
            building.constructionProgress += activeWorkers.length * 10;
            building.constructionProgress = Math.min(building.constructionProgress, 100);
            building.lastProgressUpdate = timestamp;
            
            if(building.constructionProgress >= 100) {
              building.isUnderConstruction = false;
              
              // YENÄ°: Bina tamamlanma sesleri
              if (building.kind === 'house1' || building.kind === 'house2') {
                playSoundEffect('houseSound');
              } else if (building.kind === 'stonehouse') {
                playSoundEffect('stonemasonSound');
              } else if (building.kind === 'lumberhouse') {
                playSoundEffect('lumberSound');
              } else if (building.kind === 'hunterhouse') {
                playSoundEffect('hunterSound'); // YENÄ°: AvcÄ± evi sesi
              }
              
              activeWorkers.forEach(workerId => {
                const worker = S.entities.find(w => w.id === workerId);
                if(worker) worker.isConstructing = null;
              });
              building.constructionWorkers = [];
              
              updatePopulation();
              
              if (S.lastSelectedBuilding === building.id) {
                updateSelectionCard();
              }
            }
          }
          
          if(!building.lastProgressUpdate) {
            building.lastProgressUpdate = timestamp;
          }
        }
      });
    }

    function updateResourceCollection(timestamp) {
      if(!S.lastResourceUpdate) S.lastResourceUpdate = timestamp;
      if(timestamp - S.lastResourceUpdate < 1000) return;
      
      // AÄŸaÃ§larÄ± gÃ¼ncelle
      for (let i = S.trees.length - 1; i >= 0; i--) {
        const tree = S.trees[i];
        
        // YENÄ°: Titreme efekti kontrolÃ¼
        if (tree.wood > 0 && tree.choppingWorkers.length > 0) {
          const activeWorkers = tree.choppingWorkers.filter(workerId => {
            const worker = S.entities.find(w => w.id === workerId && w.kind === 'worker');
            return worker && Math.hypot(worker.x - tree.x, worker.y - tree.y) < 1.5;
          });
          
          if (activeWorkers.length > 0) {
            // Titreme baÅŸlat
            S.shakingTrees.add(tree);
            
            // 200ms sonra titremeyi durdur
            setTimeout(() => {
              S.shakingTrees.delete(tree);
            }, 200);
          }
        }
        
        if (tree.wood <= 0) {
          // AÄŸaÃ§ bittiÄŸinde titremeyi durdur
          S.shakingTrees.delete(tree);
          tree.choppingWorkers.forEach(workerId => {
            const worker = S.entities.find(w => w.id === workerId && w.kind === 'worker');
            if (worker) {
              worker.isChopping = null;
              worker.isDelivering = false;
              // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: AÄŸaÃ§ bittiÄŸinde iÅŸÃ§i yeni aÄŸaÃ§ bulsun
              const newTree = findNearestTree(worker.x, worker.y);
              if (newTree) {
                sendWorkersToTree(newTree, [worker]);
              } else {
                // Yeni aÄŸaÃ§ yoksa iÅŸÃ§iyi boÅŸta bÄ±rak
                worker.tx = worker.x;
                worker.ty = worker.y;
              }
            }
          });
          
          S.trees.splice(i, 1);
          continue;
        }
        
        if(tree.wood > 0 && tree.choppingWorkers.length > 0) {
          const activeWorkers = tree.choppingWorkers.filter(workerId => {
            const worker = S.entities.find(w => w.id === workerId && w.kind === 'worker');
            return worker && Math.hypot(worker.x - tree.x, worker.y - tree.y) < 1.5;
          });
          
          if(activeWorkers.length > 0) {
            tree.wood = Math.max(0, tree.wood - activeWorkers.length);
            
            activeWorkers.forEach(workerId => {
              const worker = S.entities.find(w => w.id === workerId);
              if(worker) {
                worker.carryingWood = worker.carryingWood || 0;
                worker.carryingWood += 1;
                
                if(worker.carryingWood >= 10) {
                  const storage = findNearestStorage(worker.x, worker.y, 'wood');
                  if(storage) {
                    worker.isChopping = null;
                    worker.isDelivering = true;
                    worker.tx = storage.x;
                    worker.ty = storage.y;
                    tree.choppingWorkers = tree.choppingWorkers.filter(id => id !== workerId);
                  }
                }
                
                if(tree.wood === 0 && worker.carryingWood > 0) {
                  const storage = findNearestStorage(worker.x, worker.y, 'wood');
                  if(storage) {
                    worker.isChopping = null;
                    worker.isDelivering = true;
                    worker.tx = storage.x;
                    worker.ty = storage.y;
                    tree.choppingWorkers = tree.choppingWorkers.filter(id => id !== workerId);
                  }
                }
              }
            });
            
            if(S.selection.has('tree_' + i)) {
              updateSelectionCard();
            }
          }
        }
      }
      
      // TaÅŸlarÄ± gÃ¼ncelle
      for (let i = S.stones.length - 1; i >= 0; i--) {
        const stone = S.stones[i];
        if (stone.stone <= 0) {
          stone.miningWorkers.forEach(workerId => {
            const worker = S.entities.find(w => w.id === workerId && w.kind === 'worker');
            if (worker) {
              worker.isMining = null;
              worker.isDelivering = false;
              // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: TaÅŸ bittiÄŸinde iÅŸÃ§i yeni taÅŸ bulsun
              const newStone = findNearestStone(worker.x, worker.y);
              if (newStone) {
                sendWorkersToStone(newStone, [worker]);
              } else {
                // Yeni taÅŸ yoksa iÅŸÃ§iyi boÅŸta bÄ±rak
                worker.tx = worker.x;
                worker.ty = worker.y;
              }
            }
          });
          
          S.stones.splice(i, 1);
          continue;
        }
        
        if(stone.stone > 0 && stone.miningWorkers.length > 0) {
          const activeWorkers = stone.miningWorkers.filter(workerId => {
            const worker = S.entities.find(w => w.id === workerId && w.kind === 'worker');
            return worker && Math.hypot(worker.x - stone.x, worker.y - stone.y) < 1.5;
          });
          
          if(activeWorkers.length > 0) {
            stone.stone = Math.max(0, stone.stone - activeWorkers.length);
            
            activeWorkers.forEach(workerId => {
              const worker = S.entities.find(w => w.id === workerId);
              if(worker) {
                worker.carryingStone = worker.carryingStone || 0;
                worker.carryingStone += 1;
                
                if(worker.carryingStone >= 10) {
                  const storage = findNearestStorage(worker.x, worker.y, 'stone');
                  if(storage) {
                    worker.isMining = null;
                    worker.isDelivering = true;
                    worker.tx = storage.x;
                    worker.ty = storage.y;
                    stone.miningWorkers = stone.miningWorkers.filter(id => id !== workerId);
                  }
                }
                
                if(stone.stone === 0 && worker.carryingStone > 0) {
                  const storage = findNearestStorage(worker.x, worker.y, 'stone');
                  if(storage) {
                    worker.isMining = null;
                    worker.isDelivering = true;
                    worker.tx = storage.x;
                    worker.ty = storage.y;
                    stone.miningWorkers = stone.miningWorkers.filter(id => id !== workerId);
                  }
                }
              }
            });
            
            if(S.selection.has('stone_' + i)) {
              updateSelectionCard();
            }
          }
        }
      }
      
      // Geyik avlama sistemi - Ä°ÅžÃ‡Ä° GEYÄ°ÄžÄ° TAKÄ°P ETSÄ°N
      S.deer.forEach(deer => {
        if (deer.health <= 0 && !deer.isDead) {
          // Geyik Ã¶ldÃ¼
          deer.isDead = true;
          deer.state = 'dead';
          deer.isFleeing = false;
          
          deer.huntingWorkers.forEach(workerId => {
            const worker = S.entities.find(w => w.id === workerId && w.kind === 'worker');
            if (worker) {
              worker.isHunting = null;
              // Ä°ÅŸÃ§i artÄ±k et toplamaya hazÄ±r
              worker.isCollectingMeat = deer;
              worker.tx = deer.x;
              worker.ty = deer.y;
            }
          });
          
          if(S.selection.has('deer_' + S.deer.indexOf(deer))) {
            updateSelectionCard();
          }
        }
        
        // CanlÄ± geyiklere saldÄ±rÄ± - Ä°ÅžÃ‡Ä° GEYÄ°ÄžÄ° TAKÄ°P ETSÄ°N
        if(deer.health > 0 && deer.huntingWorkers.length > 0) {
          deer.huntingWorkers.forEach(workerId => {
            const worker = S.entities.find(w => w.id === workerId && w.kind === 'worker');
            if (worker && worker.isHunting === deer) {
              // DÃœZELTÄ°LDÄ°: Ä°ÅŸÃ§i sÃ¼rekli geyiÄŸi takip etsin
              // Sadece hedef deÄŸiÅŸtiÄŸinde veya Ã§ok uzaktaysa gÃ¼ncelle
              const distanceToDeer = Math.hypot(worker.x - deer.x, worker.y - deer.y);
              
              // Geyik hareket ettiyse veya iÅŸÃ§i Ã§ok uzaktaysa hedefi gÃ¼ncelle
              if (distanceToDeer > 1.5 || 
                  Math.abs(worker.tx - deer.x) > 0.5 || 
                  Math.abs(worker.ty - deer.y) > 0.5) {
                worker.tx = deer.x;
                worker.ty = deer.y;
              }
              
              // YakÄ±nsa saldÄ±r - 20 HASAR
              if(distanceToDeer < 1.5) {
                deer.health = Math.max(0, deer.health - 20);
              }
            }
          });
          
          if(S.selection.has('deer_' + S.deer.indexOf(deer))) {
            updateSelectionCard();
          }
        }
        
        // Ã–lÃ¼ geyiklerden et toplama - 10'AR 10'AR TOPLASIN AMA BAÅžINDA DURSUN
        if(deer.isDead && deer.meat > 0) {
          S.entities.forEach(worker => {
            if(worker.kind === 'worker' && worker.isCollectingMeat === deer) {
              // Ä°ÅŸÃ§i geyiÄŸe doÄŸru hareket etsin
              worker.tx = deer.x;
              worker.ty = deer.y;
              
              if(Math.hypot(worker.x - deer.x, worker.y - deer.y) < 1.5) {
                // 10'AR 10'AR ET TOPLASIN
                const meatToCollect = Math.min(10, deer.meat);
                deer.meat -= meatToCollect;
                worker.carryingMeat = (worker.carryingMeat || 0) + meatToCollect;
                
                if(deer.meat === 0) {
                  // Depoya git
                  const storage = findNearestStorage(worker.x, worker.y, 'meat');
                  if(storage) {
                    worker.isCollectingMeat = null;
                    worker.isDelivering = true;
                    worker.tx = storage.x;
                    worker.ty = storage.y;
                  }
                }
                
                if(deer.meat === 0) {
                  worker.isCollectingMeat = null;
                  // Ã–lÃ¼ geyiÄŸi kaldÄ±r
                  setTimeout(() => {
                    const index = S.deer.indexOf(deer);
                    if (index > -1) {
                      S.deer.splice(index, 1);
                    }
                  }, 1000);
                }
                
                if(S.selection.has('deer_' + S.deer.indexOf(deer))) {
                  updateSelectionCard();
                }
              }
            }
          });
        }
      });
      
      // YENÄ°: BÄ°NAYA TESLÄ°MAT SÄ°STEMÄ°
      S.entities.forEach(worker => {
        if(worker.kind === 'worker' && worker.isDeliveringToBuilding) {
          const building = S.entities.find(b => b.id === worker.isDeliveringToBuilding);
          
          if(building && Math.hypot(worker.x - building.x, worker.y - building.y) < 0.5) {
            // Ä°ÅŸÃ§i binaya ulaÅŸtÄ±, kaynaklarÄ± bÄ±rak
            let deliveredAnything = false;
            
            if(worker.carryingWood > 0) {
              // Odun bÄ±rakma kontrolÃ¼
              if(building.kind === 'lumberhouse' || building.kind === 'town') {
                S.res.wood += worker.carryingWood;
                worker.carryingWood = 0;
                deliveredAnything = true;
              }
            }
            
            if(worker.carryingStone > 0) {
              // TaÅŸ bÄ±rakma kontrolÃ¼
              if(building.kind === 'stonehouse' || building.kind === 'town') {
                S.res.stone += worker.carryingStone;
                worker.carryingStone = 0;
                deliveredAnything = true;
              }
            }
            
            if(worker.carryingMeat > 0) {
              // Et bÄ±rakma kontrolÃ¼
              if(building.kind === 'hunterhouse' || building.kind === 'town') {
                S.res.food += worker.carryingMeat;
                worker.carryingMeat = 0;
                deliveredAnything = true;
              }
            }
            
            if(deliveredAnything) {
              worker.isDeliveringToBuilding = null;
              updateTopBar();
              
              if(S.selection.has(worker.id)) {
                updateSelectionCard();
              }
            } else {
              // Bu binaya uygun kaynak yok, iÅŸÃ§iyi serbest bÄ±rak
              worker.isDeliveringToBuilding = null;
            }
          }
        }
      });
      
      // Kaynak teslimatÄ±nÄ± iÅŸle - TESLÄ°MAT SONRASI OTOMATÄ°K Ä°Åž BULSUN
      S.entities.forEach(worker => {
        if(worker.kind === 'worker' && worker.isDelivering) {
          let storage = null;
          let resourceType = '';
          
          if(worker.carryingWood > 0) {
            storage = findNearestStorage(worker.x, worker.y, 'wood');
            resourceType = 'wood';
          } else if(worker.carryingStone > 0) {
            storage = findNearestStorage(worker.x, worker.y, 'stone');
            resourceType = 'stone';
          } else if(worker.carryingMeat > 0) {
            storage = findNearestStorage(worker.x, worker.y, 'meat');
            resourceType = 'meat';
          }
          
          if(storage && Math.hypot(worker.x - storage.x, worker.y - storage.y) < 0.5) {
            // KaynaklarÄ± teslim et
            if(worker.carryingWood > 0) {
              S.res.wood += worker.carryingWood;
              worker.carryingWood = 0;
            }
            if(worker.carryingStone > 0) {
              S.res.stone += worker.carryingStone;
              worker.carryingStone = 0;
            }
            if(worker.carryingMeat > 0) {
              S.res.food += worker.carryingMeat;
              worker.carryingMeat = 0;
            }
            
            worker.isDelivering = false;
            updateTopBar();
            
            if(S.selection.has(worker.id)) {
              updateSelectionCard();
            }
            
            // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: Ä°ÅŸÃ§i teslimattan sonra otomatik olarak yeni kaynak arasÄ±n
            let newResource = null;
            if(resourceType === 'wood') {
              newResource = findNearestTree(worker.x, worker.y);
              if(newResource) {
                sendWorkersToTree(newResource, [worker]);
              }
            } else if(resourceType === 'stone') {
              newResource = findNearestStone(worker.x, worker.y);
              if(newResource) {
                sendWorkersToStone(newResource, [worker]);
              }
            }
            // Geyik iÃ§in otomatik devam etme - sadece aÄŸaÃ§ ve taÅŸ iÃ§in
            
            if(!newResource) {
              // Yeni kaynak yoksa iÅŸÃ§iyi boÅŸta bÄ±rak
              worker.tx = worker.x;
              worker.ty = worker.y;
            }
          }
        }
      });
      
      S.lastResourceUpdate = timestamp;
    }

    function draw(timestamp){
      if(timestamp===undefined) timestamp=performance.now();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      if(!S.lastConstructionUpdate) S.lastConstructionUpdate = timestamp;
      if(timestamp - S.lastConstructionUpdate > 1000) {
        updateConstruction(timestamp);
        S.lastConstructionUpdate = timestamp;
      }
      
      updateResourceCollection(timestamp);
      updateDeerBehavior(timestamp);
      updateFogOfWar();
      updateSelectedBuildingDisplay();
	
      if (S.selection.size === 1) {
        const selectedId = [...S.selection][0];
        const selectedEntity = S.entities.find(e => e.id === selectedId);
        if (selectedEntity && selectedEntity.kind === 'worker') {
          updateWorkerResourceDisplay(selectedEntity);
        }
      }

      // YENÄ°: Kenar kaydÄ±rma kontrolÃ¼
      updateEdgeScroll();
      
      const camSpeed=10;
      // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: Capslock'tan etkilenmeyen tuÅŸ kontrolleri
      if(S.keys['w']||S.keys['arrowup']) S.cam.y-=camSpeed;
      if(S.keys['s']||S.keys['arrowdown']) S.cam.y+=camSpeed;
      if(S.keys['a']||S.keys['arrowleft']) S.cam.x-=camSpeed;
      if(S.keys['d']||S.keys['arrowright']) S.cam.x+=camSpeed;

      // KamerayÄ± harita sÄ±nÄ±rlarÄ± iÃ§inde tut - KÃ–ÅžE NOKTALARI YÃ–NTEMÄ°
      const mapWidth = (MAP_W + MAP_H) * (TW/2) * S.cam.z;
      const mapHeight = (MAP_W + MAP_H) * (TH/2) * S.cam.z;

      const minCamX = canvas.width/2 - mapWidth/2 + 100;
      const maxCamX = canvas.width/2 + mapWidth/2 - 600;
      const minCamY = canvas.height/2 - mapHeight/2 + 300;
      const maxCamY = canvas.height/2 + mapHeight/2 - 50;

      // YumuÅŸak sÄ±nÄ±r kontrolÃ¼
      S.cam.x = Math.max(minCamX, Math.min(S.cam.x, maxCamX));
      S.cam.y = Math.max(minCamY, Math.min(S.cam.y, maxCamY));

      // ZEMÄ°N Ã‡Ä°ZÄ°MÄ°
      for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){
        const {x:sx,y:sy}=isoToScreen(x+0.5,y+0.5);
        ctx.beginPath();
        ctx.moveTo(sx,sy);
        ctx.lineTo(sx+TW/2*S.cam.z,sy+TH/2*S.cam.z);
        ctx.lineTo(sx,sy+TH*S.cam.z);
        ctx.lineTo(sx-TW/2*S.cam.z,sy+TH/2*S.cam.z);
        ctx.closePath();
        ctx.fillStyle='#2d7a32'; 
        ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,.06)'; 
        ctx.stroke();
      }

      // Ä°ÅžÃ‡Ä° HAREKET GÃœNCELLEMESÄ° - ESKÄ° SÄ°STEME GERÄ° EKLENDÄ°
      S.entities.forEach(e=>{
        if(e.kind === 'worker') {
          if(!e.lastTime) e.lastTime=timestamp;
          const dx=e.tx-e.x, dy=e.ty-e.y;
          const dist=Math.hypot(dx,dy);
          if(dist>0.01){
            const deltaTime=(timestamp-e.lastTime)/1000;
            const moveAmount=MOVE_SPEED*deltaTime;
            const moveX=(dx/dist)*moveAmount;
            const moveY=(dy/dist)*moveAmount;
            let finalX = e.x + moveX;
            let finalY = e.y + moveY;

            const radius = 0.3;
            finalX = Math.max(radius, Math.min(MAP_W-1-radius, finalX));
            finalY = Math.max(radius, Math.min(MAP_H-1-radius, finalY));

            e.x=finalX; e.y=finalY;
            if(Math.hypot(e.x-e.tx,e.y-e.ty)<0.05){ e.x=e.tx; e.y=e.ty; }
          } else { e.x=e.tx; e.y=e.ty; }
          e.lastTime=timestamp;
        }
      });

      // TÃœM NESNELERÄ° TOPLA VE Y KOORDÄ°NATINA GÃ–RE SIRALA
      const allObjects = [];
      
      // AÄŸaÃ§larÄ± ekle
      S.trees.forEach(tree => {
        allObjects.push({
          type: 'tree',
          data: tree,
          y: tree.y // SÄ±ralama iÃ§in y koordinatÄ±
        });
      });
      
      // TaÅŸlarÄ± ekle
      S.stones.forEach(stone => {
        allObjects.push({
          type: 'stone', 
          data: stone,
          y: stone.y
        });
      });
      
      // Geyikleri ekle
      S.deer.forEach(deer => {
        allObjects.push({
          type: 'deer',
          data: deer, 
          y: deer.y
        });
      });
      
      // BinalarÄ± ekle (worker olmayan)
      S.entities.forEach(entity => {
        if(entity.kind !== 'worker') {
          allObjects.push({
            type: 'building',
            data: entity,
            y: entity.y
          });
        }
      });
      
      // Ä°ÅŸÃ§ileri ekle
      S.entities.forEach(entity => {
        if(entity.kind === 'worker') {
          allObjects.push({
            type: 'worker',
            data: entity,
            y: entity.y
          });
        }
      });
      
      // Y koordinatÄ±na gÃ¶re sÄ±rala (kÃ¼Ã§Ã¼k y -> bÃ¼yÃ¼k y)
      allObjects.sort((a, b) => a.y - b.y);
      
      // SIRALANMIÅž NESNELERÄ° Ã‡Ä°Z
      allObjects.forEach(obj => {
        const {x:sx,y:sy}=isoToScreen(obj.data.x, obj.data.y);
        
        switch(obj.type) {
          case 'tree':
            const tree = obj.data;
            // YENÄ°: Titreme efekti ile aÄŸaÃ§ Ã§iz
            drawTreeWithShake(ctx, tree, sx, sy);
            break;
            
          case 'stone':
            const stone = obj.data;
            let stoneImage;
            if(stone.type === 1) stoneImage = stoneImages.type1;
            else if(stone.type === 2) stoneImage = stoneImages.type2;
            else stoneImage = stoneImages.type3;
            
            if(stoneImage && stoneImage.complete) {
              ctx.drawImage(
                stoneImage, 
                sx - 24*S.cam.z,
                sy - 48*S.cam.z,
                48*S.cam.z,
                48*S.cam.z
              );
            } 

            if(S.selection.has('stone_' + S.stones.indexOf(stone))) {
              ctx.strokeStyle = 'cyan';
              ctx.beginPath();
              ctx.arc(sx, sy - 24*S.cam.z, 12*S.cam.z, 0, Math.PI*2);
              ctx.stroke();
            }
            break;
            
          case 'deer':
            const deer = obj.data;
            
            if(deer.isDead) {
              // Ã–lÃ¼ geyik - gÃ¶rsel
              if(deerImages.dead && deerImages.dead.complete) {
                ctx.save();
                // Ã–lÃ¼ geyik iÃ§in yÃ¶n deÄŸiÅŸtirme gerekmez
                ctx.drawImage(
                  deerImages.dead, 
                  sx - 24*S.cam.z,
                  sy - 48*S.cam.z,
                  48*S.cam.z,
                  48*S.cam.z
                );
                ctx.restore();
              } 

              // Et Ã§ubuÄŸu - YUKARI KALDIRILDI
              const meatPercent = (deer.meat / deer.maxMeat) * 100;
              const barWidth = 40 * S.cam.z;
              const barHeight = 4 * S.cam.z;
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(sx - barWidth/2, sy - 50*S.cam.z, barWidth, barHeight);
              ctx.fillStyle = '#FF9800';
              ctx.fillRect(sx - barWidth/2, sy - 50*S.cam.z, barWidth * (meatPercent/100), barHeight);
            } else {
              // CanlÄ± geyik - gÃ¶rsel 
              if(deerImages.alive && deerImages.alive.complete) {
                ctx.save();
                // GeyiÄŸin yÃ¶nÃ¼ne gÃ¶re gÃ¶rseli yansÄ±t
                if (deer.direction === -1) {
                  // Sola bakÄ±yorsa gÃ¶rseli yatay olarak Ã§evir
                  ctx.translate(sx, sy);
                  ctx.scale(-1, 1);
                  ctx.translate(-sx, -sy);
                }
                ctx.drawImage(
                  deerImages.alive, 
                  sx - 24*S.cam.z,
                  sy - 48*S.cam.z,
                  48*S.cam.z,
                  48*S.cam.z
                );
                ctx.restore();
              } 

              // Can Ã§ubuÄŸu - YUKARI KALDIRILDI
              const healthPercent = (deer.health / deer.maxHealth) * 100;
              const barWidth = 40 * S.cam.z;
              const barHeight = 4 * S.cam.z;
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(sx - barWidth/2, sy - 50*S.cam.z, barWidth, barHeight);
              ctx.fillStyle = healthPercent > 70 ? '#FF6B6B' : healthPercent > 30 ? '#FF5252' : '#FF0000';
              ctx.fillRect(sx - barWidth/2, sy - 50*S.cam.z, barWidth * (healthPercent/100), barHeight);
            }

            if(S.selection.has('deer_' + S.deer.indexOf(deer))) {
              ctx.strokeStyle = 'cyan';
              ctx.beginPath();
              // Geyik seÃ§im halkasÄ±nÄ± gÃ¶rselin ortasÄ±na getir
              ctx.arc(sx, sy - 24*S.cam.z, 12*S.cam.z, 0, Math.PI*2);
              ctx.stroke();
            }
            break;
            
          case 'building':
            const building = obj.data;
            
            // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: TamamlanmÄ±ÅŸ binalarda inÅŸaat efekti kaldÄ±rÄ±ldÄ±
            if(building.isUnderConstruction) {
              ctx.globalAlpha = 0.5;
            } else {
              ctx.globalAlpha = 1.0;
            }

            // TÃœM BÄ°NALAR Ä°Ã‡Ä°N GÃ–RSEL KULLANIMI
            let buildingImage = null;
            let buildingWidth = 72;
            let buildingHeight = 72;
            let offsetX = 36;
            let offsetY = 72;

            if(building.kind==='town'){ 
              buildingImage = buildingImages.town;
            }
            else if(building.kind==='house1'){ 
              buildingImage = buildingImages.house1;
            }
            else if(building.kind==='house2'){ 
              buildingImage = buildingImages.house2;
            }
            else if(building.kind==='lumberhouse'){ 
              buildingImage = buildingImages.lumberhouse;
            }
            else if(building.kind==='hunterhouse'){ 
              buildingImage = buildingImages.hunterhouse;
            }
            else if(building.kind==='stonehouse'){ 
              buildingImage = buildingImages.stonehouse;
            }

            // SADECE GÃ–RSEL VARSA VE YÃœKLENDÄ°YSE Ã‡Ä°Z
            if(buildingImage && buildingImage.complete) {
              ctx.drawImage(
                buildingImage, 
                sx - offsetX*S.cam.z,
                sy - offsetY*S.cam.z,
                buildingWidth*S.cam.z,
                buildingHeight*S.cam.z
              );
            } 

            // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: Sadece inÅŸaat halindeki binalarda inÅŸaat barÄ± gÃ¶ster
            if(building.isUnderConstruction) {
              const barWidth = 40 * S.cam.z;
              const barHeight = 4 * S.cam.z;
              // Ä°nÅŸaat barÄ±nÄ± gÃ¶rselin Ã¼stÃ¼ne yerleÅŸtir
              ctx.fillStyle = 'rgba(0,0,0,0.5)';
              ctx.fillRect(sx - barWidth/2, sy - 80*S.cam.z, barWidth, barHeight);
              ctx.fillStyle = '#FF9800';
              ctx.fillRect(sx - barWidth/2, sy - 80*S.cam.z, barWidth * (building.constructionProgress/100), barHeight);
            }

            // SeÃ§im halkasÄ± - GÃ–RSELÄ°N ORTASINDA
            if(S.selection.has(building.id)){ 
              ctx.strokeStyle='cyan'; 
              ctx.beginPath(); 
              // GÃ¶rselin ortasÄ±: sy - 36*S.cam.z (72 yÃ¼ksekliÄŸin yarÄ±sÄ±)
              ctx.arc(sx, sy - 36*S.cam.z, 15*S.cam.z, 0, Math.PI*2);
              ctx.stroke(); 
            }
            
            ctx.globalAlpha = 1.0;
            break;
            
          case 'worker':
            const worker = obj.data;
            
            ctx.beginPath(); 
            ctx.arc(sx,sy-4,6*S.cam.z,0,Math.PI*2); 
            ctx.fillStyle=worker.isConstructing ? 'orange' : 
                         worker.isChopping ? 'brown' : 
                         worker.isMining ? 'gray' :
                         worker.isHunting ? 'darkred' :
                         worker.isCollectingMeat ? 'darkorange' :
                         worker.isDeliveringToBuilding ? 'purple' :
                         worker.isDelivering ? 'darkgreen' : 'yellow'; 
            ctx.fill(); 

            if(S.selection.has(worker.id)){ 
              ctx.strokeStyle='cyan'; 
              ctx.beginPath(); 
              // Ä°ÅŸÃ§i seÃ§im halkasÄ±nÄ± gÃ¶rselin ortasÄ±na getir
              ctx.arc(sx, sy + 2*S.cam.z, 10*S.cam.z, 0, Math.PI*2);
              ctx.stroke(); 
            }
            break;
        }
      });

      if(S.dragging){
        const minX=Math.min(S.dragStart.x,S.mouse.x);
        const minY=Math.min(S.dragStart.y,S.mouse.y);
        const width=Math.abs(S.dragStart.x-S.mouse.x);
        const height=Math.abs(S.dragStart.y-S.mouse.y);
        ctx.strokeStyle='lime';
        ctx.setLineDash([6,4]);
        ctx.strokeRect(minX,minY,width,height);
        ctx.setLineDash([]);
      }

      if(S.buildMode){
        const gx=Math.floor(S.mouse.wx);
        const gy=Math.floor(S.mouse.wy);
        const {x:sx,y:sy}=isoToScreen(gx,gy);
        
        let canBuild = true;
        
        // Bina kontrolÃ¼
        for(const entity of S.entities){
          if(entity.kind === 'town' || entity.kind === 'house1' || entity.kind === 'house2' || 
             entity.kind === 'lumberhouse' || entity.kind === 'hunterhouse' ||
             entity.kind === 'stonehouse'){
            if(Math.floor(entity.x) === gx && Math.floor(entity.y) === gy){
              canBuild = false;
              break;
            }
          }
        }
        
        // AÄŸaÃ§ kontrolÃ¼
        if(canBuild){
          for(const tree of S.trees){
            if(Math.floor(tree.x) === gx && Math.floor(tree.y) === gy){
              canBuild = false;
              break;
            }
          }
        }
        
        // TaÅŸ kontrolÃ¼
        if(canBuild){
          for(const stone of S.stones){
            if(Math.floor(stone.x) === gx && Math.floor(stone.y) === gy){
              canBuild = false;
              break;
            }
          }
        }
        
        // Geyik kontrolÃ¼ EKLENDÄ°
        if(canBuild){
          for(const deer of S.deer){
            if(Math.floor(deer.x) === gx && Math.floor(deer.y) === gy){
              canBuild = false;
              break;
            }
          }
        }
        
        ctx.globalAlpha = 0.5;
        
        // Ä°nÅŸa modundaki gÃ¶rselleri kendi gÃ¶rsellerimizle deÄŸiÅŸtir
        let buildImage = null;
        let buildWidth = 72;
        let buildHeight = 72;
        let offsetX = 36;
        let offsetY = 72;

        // TÃ¼m bina tipleri iÃ§in ayrÄ± ayrÄ± kontrol
        if(S.buildMode==='house1'){ 
          buildImage = buildingImages.house1;
        }
        else if(S.buildMode==='house2'){ 
          buildImage = buildingImages.house2;
        }
        else if(S.buildMode==='lumberhouse'){ 
          buildImage = buildingImages.lumberhouse;
        }
        else if(S.buildMode==='hunterhouse'){ 
          buildImage = buildingImages.hunterhouse;
        }
        else if(S.buildMode==='stonehouse'){ 
          buildImage = buildingImages.stonehouse;
        }

        if(buildImage && buildImage.complete) {
          // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: Ä°nÅŸa edilemezse kÄ±rmÄ±zÄ± filtre uygula
          if(!canBuild) {
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.fillRect(sx - offsetX*S.cam.z, sy - offsetY*S.cam.z, buildWidth*S.cam.z, buildHeight*S.cam.z);
            ctx.globalAlpha = 0.5;
          }
          
          ctx.drawImage(
            buildImage, 
            sx - offsetX*S.cam.z,
            sy - offsetY*S.cam.z,
            buildWidth*S.cam.z,
            buildHeight*S.cam.z
          );
        } 
        
        ctx.globalAlpha = 1.0;
      }

       drawFogOfWar();

      requestAnimationFrame(draw);
    }

    function drawFogOfWar() {
      for(let y = 0; y < MAP_H; y++) {
        for(let x = 0; x < MAP_W; x++) {
          if(S.fogOfWar[y][x]) {
            const {x: sx, y: sy} = isoToScreen(x + 0.5, y + 0.5);
            
            // KaranlÄ±k alan
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + TW/2 * S.cam.z, sy + TH/2 * S.cam.z);
            ctx.lineTo(sx, sy + TH * S.cam.z);
            ctx.lineTo(sx - TW/2 * S.cam.z, sy + TH/2 * S.cam.z);
            ctx.closePath();
            
            if(S.explored[y][x]) {
              // KeÅŸfedilmiÅŸ ama gÃ¶rÃ¼nmeyen alan (tamamen opak)
              ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            } else {
              // HiÃ§ keÅŸfedilmemiÅŸ alan (tamamen opak)
              ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            }
            ctx.fill();
          }
        }
      }
    }

    requestAnimationFrame(draw);

    document.getElementById('buildBtn').onclick = () => {
      const buildMenu=document.getElementById('buildMenu');
      buildMenu.style.display = buildMenu.style.display==='none' ? 'block' : 'none';
    };
    
    // DEÄžÄ°ÅžTÄ°RÄ°LDÄ°: Ev inÅŸa tuÅŸuna basÄ±ldÄ±ÄŸÄ±nda rastgele ev tipi seÃ§
    document.getElementById('buildHouseBtn').onclick = ()=>{ 
      // Ä°nÅŸa moduna girerken rastgele ev tipini belirle
      const houseType = randomInt(1, 2) === 1 ? 'house1' : 'house2';
      S.buildMode = houseType; // Direkt house1 veya house2 moduna geÃ§
    };
    
    document.getElementById('buildLumberhouseBtn').onclick = ()=>{ S.buildMode='lumberhouse'; };
    document.getElementById('buildHunterhouseBtn').onclick = ()=>{ S.buildMode='hunterhouse'; };
    document.getElementById('buildStonehouseBtn').onclick = ()=>{ S.buildMode='stonehouse'; };

    updateTopBar();

    // YENÄ°: Kaydet/YÃ¼kle sistemi
  function saveGame() {
      const gameData = {
          resources: S.res,
          entities: S.entities.map(entity => ({
              ...entity,
              // FonksiyonlarÄ± kaydetme
              lastTime: undefined,
              lastProgressUpdate: undefined
          })),
          trees: S.trees,
          stones: S.stones,
          deer: S.deer.map(deer => ({
              ...deer,
              // FonksiyonlarÄ± ve timer'larÄ± kaydetme
              lastMoveTime: undefined,
              stateTimer: undefined,
              normalStateTimer: undefined
          })),
          fogOfWar: S.fogOfWar,
          explored: S.explored,
          timestamp: Date.now()
      };
      
      localStorage.setItem('villagerSave', JSON.stringify(gameData));
      alert('Oyun kaydedildi!');
      closeMenu();
  }

  function loadGame() {
      const saved = localStorage.getItem('villagerSave');
      if (!saved) {
          alert('KayÄ±tlÄ± oyun bulunamadÄ±!');
          return;
      }
      
      try {
          const gameData = JSON.parse(saved);
          
          // Oyun state'ini geri yÃ¼kle
          S.res = gameData.resources;
          S.entities = gameData.entities;
          S.trees = gameData.trees;
          S.stones = gameData.stones;
          S.deer = gameData.deer;
          S.fogOfWar = gameData.fogOfWar || [];
          S.explored = gameData.explored || [];
          
          // UI'Ä± gÃ¼ncelle
          updateTopBar();
          updatePopulation();
          
          // SeÃ§imi temizle
          S.selection.clear();
          updateSelectionCard();
          
          alert('Oyun yÃ¼klendi!');
          closeMenu();
      } catch (error) {
          alert('Oyun yÃ¼klenirken hata oluÅŸtu: ' + error.message);
      }
  }

  </script>
</body>
</html>